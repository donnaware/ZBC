CCS PCH C Compiler, Version 4.030, 38055               24-Nov-10 12:47

               Filename: C:\Dev1\DOS\Zet\ZetBoard\rtl\Src\PIC2550\HIDZet1.lst

               ROM used: 6376 bytes (19%)
                         Largest free fragment is 26388
               RAM used: 1103 (54%) at main() level
                         1272 (62%) worst case
               Stack:    13 worst case (6 in main + 7 for interrupts)

*
0000:  GOTO   1842
*
0008:  MOVWF  05
000A:  MOVFF  FD8,06
000E:  MOVFF  FE0,07
0012:  MOVLB  0
0014:  MOVFF  FE9,0D
0018:  MOVFF  FEA,08
001C:  MOVFF  FE1,09
0020:  MOVFF  FE2,0A
0024:  MOVFF  FD9,0B
0028:  MOVFF  FDA,0C
002C:  MOVFF  FF3,14
0030:  MOVFF  FF4,15
0034:  MOVFF  FFA,16
0038:  MOVFF  00,0F
003C:  MOVFF  01,10
0040:  MOVFF  02,11
0044:  MOVFF  03,12
0048:  MOVFF  04,13
004C:  BTFSS  FA0.5
004E:  GOTO   0058
0052:  BTFSC  FA1.5
0054:  GOTO   0BFC
0058:  MOVFF  0F,00
005C:  MOVFF  10,01
0060:  MOVFF  11,02
0064:  MOVFF  12,03
0068:  MOVFF  13,04
006C:  BSF    0E.7
006E:  MOVFF  0D,FE9
0072:  MOVFF  08,FEA
0076:  MOVFF  09,FE1
007A:  MOVFF  0A,FE2
007E:  MOVFF  0B,FD9
0082:  MOVFF  0C,FDA
0086:  MOVFF  14,FF3
008A:  MOVFF  15,FF4
008E:  MOVFF  16,FFA
0092:  MOVF   05,W
0094:  MOVFF  07,FE0
0098:  MOVFF  06,FD8
009C:  RETFIE 0
.................... //============================================================================== 
.................... //============================================================================== 
.................... // ZBC.c -- Zet FPGA interface                                                -- 
.................... // ----------------------------------------------------------------------------- 
.................... //  DonnaWare International LLP Copyright (2001) All Rights Reserved           
.................... //============================================================================== 
.................... //============================================================================== 
.................... #include "HIDZet1.h"        // Main Project Includes 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... //  FPGAEtchey1.c --  PIC FPGAEtchey                                          
.................... // DonnaWare International LLP Copyright (2001) All Rights Reserved         
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... #include <18F2550.h> 
.................... //////// Standard Header file for the PIC18F2550 device //////////////// 
.................... #device PIC18F2550 
.................... #list 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Compile Switches 
.................... //------------------------------------------------------------------------------ 
.................... #define DEBUGON     1   // Set to 1 to enable debugging functions 
.................... //------------------------------------------------------------------------------ 
.................... #fuses HSPLL,USBDIV,PLL5,CPUDIV2,VREGEN,NOFCMEN,NOIESO,PUT,NOBROWNOUT,NOWDT,NOPROTECT,NOLVP,NODEBUG,NOPBADEN,MCLR,NOWRTD 
.................... //------------------------------------------------------------------------------ 
.................... #use delay(clock=48000000)  //~~~ 20MHZ OSCILLATOR CONFIGS ~~~ FULL SPEED 
*
0DB4:  CLRF   FEA
0DB6:  MOVLW  D6
0DB8:  MOVWF  FE9
0DBA:  MOVF   FEF,W
0DBC:  BZ    0DDA
0DBE:  MOVLW  0F
0DC0:  MOVWF  01
0DC2:  CLRF   00
0DC4:  DECFSZ 00,F
0DC6:  BRA    0DC4
0DC8:  DECFSZ 01,F
0DCA:  BRA    0DC2
0DCC:  MOVLW  8F
0DCE:  MOVWF  00
0DD0:  DECFSZ 00,F
0DD2:  BRA    0DD0
0DD4:  NOP   
0DD6:  DECFSZ FEF,F
0DD8:  BRA    0DBE
0DDA:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //  Use fast I/O for all Ports 
.................... //------------------------------------------------------------------------------ 
.................... #use fast_io(A)     // Use Fast I/O for Port A 
.................... #use fast_io(B)     // Use Fast I/O for Port B 
.................... #use fast_io(C)     // Use Fast I/O for Port B 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // CCS Library dynamic defines.  For dynamic configuration of the CCS Library 
.................... // for your application several defines need to be made.  See the comments 
.................... // at usb.h for more information 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //Tells the CCS PIC USB firmware to include HID handling code. 
.................... //------------------------------------------------------------------------------ 
.................... #define USB_USE_FULL_SPEED          TRUE  
.................... #define USB_HID_DEVICE              TRUE 
.................... #define USB_REPORT_SIZE_RX          64   
.................... #define USB_REPORT_SIZE_TX          USB_REPORT_SIZE_RX  
.................... #define USB_MAX_EP0_PACKET_LENGTH   64 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // the following defines needed for the CCS USB PIC driver to enable the TX endpoint 1 
.................... // and allocate buffer space on the peripheral 
.................... //------------------------------------------------------------------------------ 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT   //turn on EP1 for IN bulk/interrupt transfers 
.................... #define USB_EP1_TX_SIZE    USB_REPORT_SIZE_TX     //allocate bytes in the hardware for transmission 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //the following defines needed for the CCS USB PIC driver to enable the RX endpoint 1 
.................... // and allocate buffer space on the peripheral 
.................... //------------------------------------------------------------------------------ 
.................... #define USB_EP1_RX_ENABLE  USB_ENABLE_INTERRUPT   //turn on EP1 for OUT bulk/interrupt transfers 
.................... #define USB_EP1_RX_SIZE    USB_REPORT_SIZE_RX     //allocate bytes in the hardware for reception 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // Include the CCS USB Libraries.  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... #include <pic18_usb_v2.h>       // Microchip PIC18Fxx5x hardware layer for usb.c 
.................... /////////////////////////////////////////////////////////////////////////  
.................... ////                          pic18_usb.c                            ////  
.................... ////                                                                 ////  
.................... //// Hardware layer for CCS's USB library.  This hardware layer      ////  
.................... //// supports the USB peripheral on the PIC18 family chips.  Current ////  
.................... //// supported families are:                                         ////  
.................... ////     PIC18F2455/2550/4455/4550                                   ////  
.................... ////     PIC18F2450/4450                                             ////  
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       ////  
.................... ////                                                                 ////  
.................... //// This file is part of CCS's PIC USB driver code, which includes: ////  
.................... ////   usb_desc_*.h - an example set of config and device descriptor ////  
.................... ////   usb.c - USB token and request handler code                    ////  
.................... ////   usb.h - definitions, prototypes and global variables          ////  
.................... ////                                                                 ////  
.................... //// The following examples are provided by CCS:                     ////  
.................... ////   ex_usb_mouse.c - A HID Mouse.                                 ////  
.................... ////   ex_usb_hid.c - A custom application using HID protocol.       ////  
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple  ////  
.................... ////                      interfaces.                                ////  
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple ////  
.................... ////                      HID Reports.                               ////  
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom        ////  
.................... ////                    protocol requiring custom Windows drivers.   ////  
.................... ////   ex_usb_serial.c -                                             ////  
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for   ////  
.................... ////     a virtual COM port.                                         ////  
.................... ////                                                                 ////  
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    ////  
.................... ////  Due to the limited USB RAM of this family, a limitation of     ////  
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   ////  
.................... ////  The HW actually supports more endpoints, but to simplify       ////  
.................... ////  driver development this driver will only support the first 3   ////  
.................... ////  so there is an easier memory block to work with.               ////  
.................... ////                                                                 ////  
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     ////  
.................... ////  of USB speed, to save RAM.                                     ////  
.................... ////                                                                 ////  
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    ////  
.................... ////  If you are not using internal pullups, you will need to put    ////  
.................... ////  an internal pullup resistor on C4 or C5 depending on if you    ////  
.................... ////  want to use slow speed or full speed.  This code configures    ////  
.................... ////  the device to use internal pullups, see usb_init() if you      ////  
.................... ////  want to change that.                                           ////  
.................... ////                                                                 ////  
.................... ////  You need approximately 470nF cap on C3, even if you are using  ////  
.................... ////  the internal 3.3V USB regulator.                               ////  
.................... ////                                                                 ////  
.................... ////  To run at full speed, you must use the oscillator              ////  
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   ////  
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     ////  
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      ////  
.................... ////  96MHz clock.  See the datasheet for details.                   ////  
.................... ////                                                                 ////  
.................... ////  To run at slow speed you must configure your MCU to run at     ////  
.................... ////  24Mhz.  See the datasheet for details.                         ////  
.................... ////                                                                 ////  
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   ////  
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the ////  
.................... //// PIC when an event has happened on the USB Bus.  Therfore        ////  
.................... //// this code enables interrupts.  A user modification can be made  ////  
.................... //// to poll the USB interrupt flag instead of relying on an         ////  
.................... //// interrupt.                                                      ////  
.................... ////                                                                 ////  
.................... ////    ****************   USER FUNCTIONS  ***********************   ////  
.................... ////                                                                 ////  
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and  ////  
.................... ////              attaches the unit to the usb bus.  Enables         ////  
.................... ////              interrupts.                                        ////  
.................... ////                                                                 ////  
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit      ////  
.................... ////              to usb bus or enable interrupts.                   ////  
.................... ////                                                                 ////  
.................... //// usb_put_packet() - Sends one packet to the host.                ////  
.................... ////                    If you need to send a message that spans     ////  
.................... ////                    more than one packet then see usb_puts() in  ////  
.................... ////                    usb.c                                        ////  
.................... ////                                                                 ////  
.................... //// usb_kbhit() - Returns true if OUT endpoint contains data from   ////  
.................... ////               host.                                             ////  
.................... ////                                                                 ////  
.................... //// usb_rx_packet_size() - Returns the size of packet that was      ////  
.................... ////               received.  usb_kbhit() must return TRUE else      ////  
.................... ////               this is not valid.  Don't forget in USB there     ////  
.................... ////               are 0 len packets!                                ////  
.................... ////                                                                 ////  
.................... //// usb_get_packet() - Gets one packet that from the host.          ////  
.................... ////                    usb_kbhit() must return true before you call ////  
.................... ////                    this routine or your data may not be valid.  ////  
.................... ////                    Once usb_kbhit() returns true you want to    ////  
.................... ////                    call this as soon as possible to get data    ////  
.................... ////                    out of the endpoint buffer so the PC can     ////  
.................... ////                    start sending more data, if needed.          ////  
.................... ////                    This only receives one packet, if you are    ////  
.................... ////                    trying to receive a multi-packet message     ////  
.................... ////                    see usb_gets() in usb.c.                     ////  
.................... ////                                                                 ////  
.................... //// usb_detach() - De-attach USB from the system.                   ////  
.................... ////                                                                 ////  
.................... //// usb_attach() - Attach USB to the system.                        ////  
.................... ////                                                                 ////  
.................... //// usb_attached() - Returns TRUE if the device is attached to a    ////  
.................... ////                  USB cable.  A macro that looks at the defined  ////  
.................... ////                  connection sense pin.                          ////  
.................... ////                                                                 ////  
.................... //// usb_task() - Keeps track of connection sense, calling           ////  
.................... ////              usb_detach() and usb_attach() when needed.         ////  
.................... ////                                                                 ////  
.................... //// For more documentation on these functions read the comments at  ////  
.................... //// each function.                                                  ////  
.................... ////                                                                 ////  
.................... //// The other functions defined in this file are for use by the     ////  
.................... //// USB code, and is not meant to be used by the user.              ////  
.................... ////                                                                 ////  
.................... /////////////////////////////////////////////////////////////////////////  
.................... ////                                                                 ////  
.................... //// Version History:                                                ////  
.................... ////                                                                 ////  
.................... ////   07-17-07: Added 18F4450,2450 support                          ////  
.................... ////                                                                 ////  
.................... ////   07-13-07: Added 87J50 family support                          ////  
.................... ////                                                                 ////  
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        ////  
.................... ////               changed for the better.                           ////  
.................... ////                                                                 ////  
.................... ////   10-28-05: Added usb_rx_packet_size()                          ////  
.................... ////                                                                 ////  
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     ////  
.................... ////             usb_flush_in() changed for 16bit packet sizes       ////  
.................... ////             usb_get_packet() changed for 16bit packet sizes     ////  
.................... ////             usb_flush_out() changed for 16bit packet sizes      ////  
.................... ////             usb_set_configured() changed for 16bit packet sizes ////  
.................... ////                                                                 ////  
.................... ////   06-30-05: usb_tbe() added                                     ////  
.................... ////             The way endpoint 0 DTS is set has been changed.     ////  
.................... ////                                                                 ////  
.................... ////   06-20-05: Initial Release                                     ////  
.................... ////                                                                 ////  
.................... ////   05-13-05: Beta Release (Full Speed works)                     ////  
.................... ////                                                                 ////  
.................... ////   03-21-05: Initial Alpha Release                               ////  
.................... ////                                                                 ////  
.................... /////////////////////////////////////////////////////////////////////////  
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         ////  
.................... //// This source code may only be used by licensed users of the CCS  ////  
.................... //// C compiler.  This source code may only be distributed to other  ////  
.................... //// licensed users of the CCS C compiler.  No other use,            ////  
.................... //// reproduction or distribution is permitted without written       ////  
.................... //// permission.  Derivative programs created using this software    ////  
.................... //// in object code form are not restricted in any way.              ////  
.................... /////////////////////////////////////////////////////////////////////////  
.................... #IFNDEF __USB_HARDWARE__  
.................... #DEFINE __USB_HARDWARE__  
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral  
.................... #DEFINE __PIC__ 1  
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50"))  
....................     #define __USB_87J50__  
....................     #define USB_TOTAL_BUFFER_SPACE  ((int16)getenv("RAM")-0x500)  
....................     #define USB_MAX_NUM_ENDPOINTS  16  
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450"))  
....................     #define __USB_4450__  
....................     #ifdef(USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+USB_EP15_TX_SIZE+USB_EP15_RX_SIZE)>0  
....................         #error This driver only supports endpoints 0, 1 and 2 for this chip.  
....................     #endif 
....................     #define USB_MAX_NUM_ENDPOINTS  3 
....................     #define USB_TOTAL_BUFFER_SPACE (0x100 - USB_MAX_NUM_ENDPOINTS * 8)  
.................... #else  
....................     #define __USB_4550__  
....................     #define USB_TOTAL_BUFFER_SPACE ((int16)0x300)  
....................     #define USB_MAX_NUM_ENDPOINTS  16  
.................... #endif  
....................  
.................... #ifndef USB_USE_FULL_SPEED  
....................     #define USB_USE_FULL_SPEED  TRUE  
.................... #endif  
....................  
.................... #ifndef USB_CON_SENSE_PIN  
....................     #define USB_CON_SENSE_PIN  0  
.................... #endif  
....................  
.................... #if defined(__USB_4450__) 
....................     #ifndef USB_MAX_EP0_PACKET_LENGTH 
....................         #define USB_MAX_EP0_PACKET_LENGTH   8 
....................     #endif  
.................... #else  
....................    #if USB_USE_FULL_SPEED == FALSE            
....................       #define USB_MAX_EP0_PACKET_LENGTH   8     //slow speed requires 8byte max packet size for endpoint 0 
....................    #else  
....................      #define USB_MAX_EP0_PACKET_LENGTH   64    //for full speed you can still use 8bytes, but 64 will be faster  
....................    #endif  
.................... #endif  
....................  
.................... #include <usb.h>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... ////                   **** DEFINITIONS *****                          //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (FALSE) - Set to TRUE if your device supports        //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            Only the 18Fxx5x USB peripheral can    //// 
.................... ////                            have a value larger than 8.            //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE  //set to false to opt for less RAM, true to opt for less ROM 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     0 
.................... #define USB_ENABLE_BULK         0x01 
.................... #define USB_ENABLE_ISOCHRONOUS  0x02 
.................... #define USB_ENABLE_INTERRUPT    0x03 
.................... #define USB_ENABLE_CONTROL      0x04 
....................  
.................... //// DO NOT CHANGE THE FOLLOWING VALUES: 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #else 
.................... struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #endif 
....................  
.................... int16 __usb_kbhit_status; 
....................  
.................... /// *** User function prototypes 
.................... void usb_wait_for_enumeration(void); 
.................... int1 usb_unermated(void); 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout); 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout); 
....................  
.................... /// *** Token and request hanlder function prototypes 
.................... void usb_token_reset(); 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_request_send_response(int len);   //always sends usb_ep0_rx_buffer[] to endpoint 0 with a toggle of DATA 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tok_in_dne(int8 endpoint); 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
....................  
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
....................  
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
....................  
.................... void usb_finish_set_address(void); 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #define USB_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+USB_EP15_TX_SIZE+USB_EP15_RX_SIZE)  
....................  
....................  
.................... #if (USB_BUFFER_NEEDED > USB_TOTAL_BUFFER_SPACE)  
....................     #error You are trying to allocate more memory for endpoints than the PIC can handle  
.................... #endif  
....................  
.................... #if defined(__USB_4450__)  
....................     #reserve 0x400:0x4FF  
.................... #else  
....................     #reserve 0x400:0x4FF+USB_BUFFER_NEEDED  
.................... #endif  
....................  
.................... #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z)  
.................... //  #define debug_usb printf  
.................... //  #define debug_putc putc_tbe  
.................... #define debug_display_ram(x,y)  
.................... /*  
.................... void debug_display_ram(int8 len, int8 *ptr) {  
....................    int8 max=16;  
....................    debug_usb(debug_putc,"%U - ",len);  
....................    if (max>len) {max=len;}  
....................    while(max--) {  
....................       debug_usb(debug_putc,"%X",*ptr);  
....................       len--;  
....................       ptr++;  
....................    }  
....................    if (len) {debug_usb(debug_putc,"...");}  
.................... }  
.................... */  
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the  
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on  
.................... //receiving.  
.................... #ifndef USB_IGNORE_RX_DTS  
....................     #define USB_IGNORE_RX_DTS FALSE  
.................... #endif  
....................  
.................... #ifndef USB_IGNORE_TX_DTS  
....................     #define USB_IGNORE_TX_DTS FALSE  
.................... #endif  
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the  
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time.  
.................... #ifndef USB_USE_ERROR_COUNTER  
....................    #define USB_USE_ERROR_COUNTER FALSE  
.................... #endif  
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong  
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only  
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints  
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS!  
.................... #ifndef USB_PING_PONG_MODE  
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF  
.................... #endif  
....................  
.................... #if USB_USE_ERROR_COUNTER  
....................    int ERROR_COUNTER[6];  
.................... #endif  
....................  
.................... //---pic18fxx5x memory locations  
.................... //#if defined(__USB_4550__)  
....................    #byte UFRML   =  0xF66  
....................    #byte UFRMH   =  0xF67  
....................    #byte UIR     =  0xF68  
....................    #byte UIE     =  0xF69  
....................    #byte UEIR    =  0xF6A  
....................    #byte UEIE    =  0xF6B  
....................    #byte USTAT   =  0xF6C  
....................    #byte UCON    =  0xF6D  
....................    #byte UADDR   =  0xF6E  
....................    #byte UCFG    =  0xF6F  
....................    #define  UEP0_LOC 0xF70  
.................... /*#else  
....................    #byte UFRML   =  0xF60  
....................    #byte UFRMH   =  0xF61  
....................    #byte UIR     =  0xF62  
....................    #byte UIE     =  0xF5C  
....................    #byte UEIR    =  0xF63  
....................    #byte UEIE    =  0xF5D  
....................    #byte USTAT   =  0xF64  
....................    #byte UCON    =  0xF65  
....................    #byte UADDR   =  0xF5E  
....................    #byte UCFG    =  0xF5F  
....................    #define  UEP0_LOC 0xF4C  
.................... #endif  
.................... */  
.................... #byte UEP0    =  UEP0_LOC  
....................  
.................... #if defined(__USB_4450__)  
.................... //  #define USB_BUFFER (0x400 + (USB_MAX_NUM_ENDPOINTS*8))  
....................     #define USB_BUFFER 0x418   //if you have an old compiler you will need to use this  
.................... #else  
....................     #define USB_BUFFER 0x500  
.................... #endif  
....................  
.................... #byte BD0STAT  =  0x400  
.................... #byte BD0CNT   =  0x401  
.................... #byte BD0ADRL  =  0x402  
.................... #byte BD0ADRJ  =  0x403  
....................  
.................... #define BD0STAT_LOC 0x400  
.................... #define BD0CNT_LOC  0x401  
.................... #define BD0ADRL_LOC 0x402  
.................... #define BD0ADRH_LOC 0x403  
....................  
.................... #define UEP(x) *(UEP0_LOC+x)  
....................  
.................... #BIT UIR_SOF   = UIR.6  
.................... #BIT UIR_STALL = UIR.5  
.................... #BIT UIR_IDLE  = UIR.4  
.................... #BIT UIR_TRN   = UIR.3  
.................... #BIT UIR_ACTV  = UIR.2  
.................... #BIT UIR_UERR  = UIR.1  
.................... #BIT UIR_URST  = UIR.0  
....................  
.................... #BIT UIE_SOF   = UIE.6  
.................... #BIT UIE_STALL = UIE.5  
.................... #BIT UIE_IDLE  = UIE.4  
.................... #BIT UIE_TRN   = UIE.3  
.................... #BIT UIE_ACTV  = UIE.2  
.................... #BIT UIE_UERR  = UIE.1  
.................... #BIT UIE_URST  = UIE.0  
....................  
.................... #bit UCON_PBRST  = UCON.6  
.................... #bit UCON_SE0    = UCON.5  
.................... #bit UCON_PKTDIS = UCON.4  
.................... #bit UCON_USBEN  = UCON.3  
.................... #bit UCON_RESUME = UCON.2  
.................... #bit UCON_SUSPND = UCON.1  
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF)  
....................     #define EP_BDxST_O(x)  * (BD0STAT_LOC + x*8)  
....................     #define EP_BDxCNT_O(x) * (BD0CNT_LOC + x*8)  
....................     #define EP_BDxADR_O(x) * (int16 *)(BD0ADRL_LOC + x*8)  
....................     #define EP_BDxST_I(x)  * (BD0STAT_LOC + 4 + x*8)  
....................     #define EP_BDxCNT_I(x) * (BD0CNT_LOC + 4 + x*8)  
....................     #define EP_BDxADR_I(x) * (int16 *)(BD0ADRL_LOC + 4 + x*8)  
.................... #else  
....................     #error Right now this driver only supports no ping pong  
.................... #endif  
....................  
.................... //See UEPn (0xF70-0xF7F)  
.................... #define ENDPT_DISABLED      0x00    //endpoint not used  
.................... #define ENDPT_IN_ONLY       0x02    //endpoint supports IN transactions only  
.................... #define ENDPT_OUT_ONLY      0x04    //endpoint supports OUT transactions only  
.................... #define ENDPT_CONTROL       0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0  
.................... #define ENDPT_NON_CONTROL   0x0E    //Supports both IN and OUT transactions  
....................  
.................... //Define the states that the USB interface can be in  
.................... enum { 
....................     USB_STATE_DETACHED  = 0,  
....................     USB_STATE_ATTACHED  = 1, 
....................     USB_STATE_POWERED   = 2, 
....................     USB_STATE_DEFAULT   = 3, 
....................     USB_STATE_ADDRESS   = 4, 
....................     USB_STATE_CONFIGURED= 5 
.................... } usb_state=0; 
....................  
.................... //--BDendST has their PIDs upshifed 2  
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions  
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions  
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction  
....................  
.................... #define USTAT_IN_E0         4  
.................... #define USTAT_OUT_SETUP_E0  0  
....................  
.................... #define __USB_UIF_RESET     0x01  
.................... #define __USB_UIF_ERROR     0x02  
.................... #define __USB_UIF_ACTIVE    0x04  
.................... #define __USB_UIF_TOKEN     0x08  
.................... #define __USB_UIF_IDLE      0x10  
.................... #define __USB_UIF_STALL     0x20  
.................... #define __USB_UIF_SOF       0x40  
....................  
.................... #if USB_USE_ERROR_COUNTER  
....................     #define STANDARD_INTS 0x3F  
.................... #else  
....................     #define STANDARD_INTS 0x3D  
.................... #endif  
....................  
.................... #define __USB_UCFG_UTEYE   0x80  
.................... #if defined(__USB_4550__)  
....................     #define __USB_UCFG_UOEMON  0x40  
.................... #endif 
....................  
.................... #define __USB_UCFG_UPUEN   0x10  
.................... #define __USB_UCFG_UTRDIS  0x08  
.................... #define __USB_UCFG_FSEN    0x04  
....................  
.................... #if USB_USE_FULL_SPEED  
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE)  
.................... #else  
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_UPUEN | USB_PING_PONG_MODE);  
.................... #endif  
....................  
.................... #define __UCFG_VAL_DISABLED__ 0x08  
....................  
.................... char usb_ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH];  
.................... #locate usb_ep0_rx_buffer=USB_BUFFER  
....................  
.................... char usb_ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH];  
.................... #locate usb_ep0_tx_buffer=USB_BUFFER+USB_MAX_EP0_PACKET_LENGTH  
....................  
.................... char usb_data_buffer[USB_TOTAL_BUFFER_SPACE-USB_MAX_EP0_PACKET_LENGTH-USB_MAX_EP0_PACKET_LENGTH];  
.................... #locate usb_data_buffer=USB_BUFFER+USB_MAX_EP0_PACKET_LENGTH+USB_MAX_EP0_PACKET_LENGTH  
....................  
.................... int8 __setup_0_tx_size;  
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only  
.................... void usb_handle_interrupt();  
.................... void usb_isr_rst();  
.................... void usb_isr_uerr();  
.................... void usb_isr_sof(void);  
.................... void usb_isr_activity();  
.................... void usb_isr_uidle();  
.................... void usb_isr_tok_dne();  
.................... void usb_isr_stall(void);  
.................... void usb_init_ep0_setup(void);  
....................  
.................... //following functions standard part of CCS PIC USB driver, and used by usb.c  
.................... void usb_init();  
.................... void usb_detach();  
.................... int1 usb_put_packet(int endpoint, int * ptr, int16 len, USB_DTS_BIT tgl);  
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); //marks the transmit buffer as ready for transmission  
.................... int16 usb_get_packet(int8 endpoint, int8 * ptr, int16 max);  
.................... int16 usb_rx_packet_size(int8 endpoint);  
.................... int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max);  
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl);  
.................... void usb_stall_ep(int8 endpoint);  
.................... void usb_unstall_ep(int8 endpoint);  
.................... int1 usb_endpoint_stalled(int8 endpoint);  
.................... void usb_set_address(int8 address);  
.................... void usb_set_configured(int config);  
.................... void usb_disable_endpoints(void);  
....................  
.................... //// BEGIN User Functions:  
....................  
.................... /******************************************************************************  
.................... /* usb_attached()  
.................... /*  
.................... /* Summary: Returns TRUE if the device is attached to a USB cable  
.................... /*  
.................... /*****************************************************************************/  
.................... #if USB_CON_SENSE_PIN  
....................     #define usb_attached() input(USB_CON_SENSE_PIN)  
.................... #else  
....................     #define usb_attached() TRUE  
.................... #endif  
....................  
.................... /******************************************************************************  
.................... /* usb_detach()  
.................... /*  
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB.  
.................... /*  
.................... /*****************************************************************************/  
.................... void usb_detach(void) {  //done  
....................    UCON=0;  //disable USB hardware  
*
0D14:  CLRF   F6D
....................    UIE=0;   //disable USB interrupts  
0D16:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__;  
0D18:  MOVLW  08
0D1A:  MOVWF  F6F
....................    set_tris_c(*0xF94 | 0x30);  
0D1C:  MOVF   F94,W
0D1E:  IORLW  30
0D20:  MOVWF  F94
....................    usb_state=USB_STATE_DETACHED;  
0D22:  CLRF   1F
0D24:  CLRF   18
0D26:  BTFSC  FF2.7
0D28:  BSF    18.7
0D2A:  BCF    FF2.7
....................    usb_token_reset();              //clear the chapter9 stack  
0D2C:  CALL   020A
0D30:  BTFSC  18.7
0D32:  BSF    FF2.7
....................    __usb_kbhit_status=0;  
0D34:  CLRF   1E
0D36:  CLRF   1D
.................... }  
0D38:  GOTO   18AA (RETURN)
....................  
.................... /******************************************************************************  
.................... /* usb_attach()  
.................... /*  
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral.  
.................... /*  
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt  
.................... /*  
.................... /*****************************************************************************/  
.................... void usb_attach(void) {  
*
106C:  CLRF   18
106E:  BTFSC  FF2.7
1070:  BSF    18.7
1072:  BCF    FF2.7
....................    usb_token_reset();  
1074:  CALL   020A
1078:  BTFSC  18.7
107A:  BSF    FF2.7
....................     UCON = 0;  
107C:  CLRF   F6D
....................    UCFG = __UCFG_VAL_ENABLED__;  
107E:  MOVLW  14
1080:  MOVWF  F6F
....................     UIE = 0;                                // Mask all USB interrupts  
1082:  CLRF   F69
....................     UCON_USBEN = 1;                     // Enable module & attach to bus  
1084:  BSF    F6D.3
....................     usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h  
1086:  MOVLW  01
1088:  MOVWF  1F
.................... }  
108A:  GOTO   1094 (RETURN)
....................  
.................... /*****************************************************************************  
.................... /* usb_init_cs()  
.................... /*  
.................... /* Summary: Resets and initalizes USB peripheral.  Does not attach the peripheral  
.................... /*          to the USB bus.  See usb_attach() and usb_task() on how to  
.................... /*          attach to the USB bus.  
.................... /*  
.................... /*          You must call this before any other USB code.  
.................... /*  
.................... /*          NOTE: an alternative function, usb_init(), is provided that  
.................... /*                initializes the USB and then connects.  
.................... /*  
.................... /*****************************************************************************/  
.................... #define usb_init_cs usb_detach  
....................  
.................... /*****************************************************************************  
.................... /* usb_task()  
.................... /*  
.................... /* Summary: Keeps an eye on the connection sense pin to determine if we are  
.................... /*          attached to a USB cable or not.  If we are attached to a USB cable,  
.................... /*          initialize the USB peripheral if needed.  If we are disconnected  
.................... /*          from the USB cable, disable the USB peripheral.  
.................... /*  
.................... /*          NOTE: If you are not using a connection sense pin, will automatically  
.................... /*                enable the USB peripheral.  
.................... /*  
.................... /*          NOTE: this enables interrupts once the USB peripheral is ready  
.................... /*  
.................... /*****************************************************************************/  
.................... void usb_task(void)  
.................... { 
....................    if (usb_attached()) {  
....................       if (UCON_USBEN==0) {  
108E:  BTFSC  F6D.3
1090:  BRA    1094
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH");  
....................          usb_attach();  
1092:  BRA    106C
....................       }  
....................    }  
....................    else {  
....................       if (UCON_USBEN==1)  {  
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH");  
....................          usb_detach();  
....................       }  
....................    }  
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0)) {  
1094:  DECFSZ 1F,W
1096:  BRA    10AE
1098:  BTFSC  F6D.5
109A:  BRA    10AE
....................       UIR=0;  
109C:  CLRF   F68
....................       UIE=0;  
109E:  CLRF   F69
....................       enable_interrupts(INT_USB);  
10A0:  BSF    FA0.5
....................       enable_interrupts(GLOBAL);  
10A2:  MOVLW  C0
10A4:  IORWF  FF2,F
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB interrupt  
10A6:  MOVLW  11
10A8:  MOVWF  F69
....................       usb_state=USB_STATE_POWERED;  
10AA:  MOVLW  02
10AC:  MOVWF  1F
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED");  
....................    }  
.................... }  
10AE:  RETLW  00
....................  
.................... /*****************************************************************************  
.................... /* usb_init()  
.................... /*  
.................... /* Summary: Resets and initalizes USB hardware.  You must call this first before  
.................... /*          using code.  Will attach the USB periperhal to the USB bus.  
.................... /*  
.................... /*          NOTE: If you are using a connection sense pin, this will wait in  
.................... /*                an infinite loop until the device is connected to a USB cable.  
.................... /*  
.................... /*          NOTE: If you are not using a connection sense pin, this will wait  
.................... /*                in an infinte loop until the SE0 condition clears, which usually  
.................... /*                doesn't take long  
.................... /*  
.................... /*          NOTE: this enables interrupts.  
.................... /*  
.................... /*****************************************************************************/  
.................... void usb_init(void) {  
....................    usb_init_cs();  
....................  
....................    do {  
....................       usb_task();  
....................    } while (usb_state != USB_STATE_POWERED);  
.................... }  
....................  
....................  
.................... /**************************************************************  
.................... /* usb_flush_in()  
.................... /*  
.................... /* Input: endpoint - which endpoint to mark for transfer  
.................... /*        len - length of data that is being tramsferred  
.................... /*        tgl - Data toggle synchronization for this packet  
.................... /*  
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint)  
.................... /*  
.................... /* Summary: Marks the endpoint ready for transmission.  You must  
.................... /*          have already loaded the endpoint buffer with data.  
.................... /*          (IN is PIC -> PC)  
.................... /***************************************************************/  
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl) {  
....................    int8 i;  
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len);  
....................  
....................    i=EP_BDxST_I(endpoint);  
*
09EE:  MOVF   xED,W
09F0:  MULLW  08
09F2:  MOVF   FF3,W
09F4:  ADDLW  04
09F6:  MOVWF  01
09F8:  MOVLW  04
09FA:  MOVWF  03
09FC:  BTFSC  FD8.0
09FE:  INCF   03,F
0A00:  MOVFF  01,FE9
0A04:  MOVFF  03,FEA
0A08:  MOVFF  FEF,F1
....................    if (!bit_test(i,7)) {  
0A0C:  BTFSC  xF1.7
0A0E:  BRA    0AC6
....................  
....................       EP_BDxCNT_I(endpoint)=len;  
0A10:  MOVF   xED,W
0A12:  MULLW  08
0A14:  MOVF   FF3,W
0A16:  ADDLW  05
0A18:  MOVWF  01
0A1A:  MOVLW  04
0A1C:  MOVWF  03
0A1E:  BTFSC  FD8.0
0A20:  INCF   03,F
0A22:  MOVFF  01,FE9
0A26:  MOVFF  03,FEA
0A2A:  MOVFF  EE,FEF
....................  
....................      debug_display_ram(len, EP_BDxADR_I(endpoint));  
....................  
....................      #if USB_IGNORE_TX_DTS  
....................       i=0x80;  
....................      #else  
....................       if (tgl == USB_DTS_TOGGLE) {  
0A2E:  MOVF   xF0,W
0A30:  SUBLW  02
0A32:  BNZ   0A60
....................          i=EP_BDxST_I(endpoint);  
0A34:  MOVF   xED,W
0A36:  MULLW  08
0A38:  MOVF   FF3,W
0A3A:  ADDLW  04
0A3C:  MOVWF  01
0A3E:  MOVLW  04
0A40:  MOVWF  03
0A42:  BTFSC  FD8.0
0A44:  INCF   03,F
0A46:  MOVFF  01,FE9
0A4A:  MOVFF  03,FEA
0A4E:  MOVFF  FEF,F1
....................          if (bit_test(i,6))  
0A52:  BTFSS  xF1.6
0A54:  BRA    0A5A
....................             tgl=USB_DTS_DATA0;  //was DATA1, goto DATA0  
0A56:  CLRF   xF0
....................          else  
0A58:  BRA    0A5E
....................             tgl=USB_DTS_DATA1;  //was DATA0, goto DATA1  
0A5A:  MOVLW  01
0A5C:  MOVWF  xF0
....................       }  
....................       else if (tgl == USB_DTS_USERX) {  
0A5E:  BRA    0A86
0A60:  MOVF   xF0,W
0A62:  SUBLW  04
0A64:  BNZ   0A86
....................          i=EP_BDxST_O(endpoint);  
0A66:  MOVF   xED,W
0A68:  MULLW  08
0A6A:  MOVFF  FF3,01
0A6E:  MOVLW  04
0A70:  MOVFF  01,FE9
0A74:  MOVWF  FEA
0A76:  MOVFF  FEF,F1
....................          if (bit_test(i,6))  
0A7A:  BTFSS  xF1.6
0A7C:  BRA    0A84
....................             tgl=USB_DTS_DATA1;  
0A7E:  MOVLW  01
0A80:  MOVWF  xF0
....................          else  
0A82:  BRA    0A86
....................             tgl=USB_DTS_DATA0;  
0A84:  CLRF   xF0
....................       }  
....................       if (tgl == USB_DTS_DATA1) {  
0A86:  DECFSZ xF0,W
0A88:  BRA    0A90
....................          i=0xC8;  //DATA1, UOWN  
0A8A:  MOVLW  C8
0A8C:  MOVWF  xF1
....................       }  
....................       else if (tgl == USB_DTS_DATA0) {  
0A8E:  BRA    0A98
0A90:  MOVF   xF0,F
0A92:  BNZ   0A98
....................          i=0x88; //DATA0, UOWN  
0A94:  MOVLW  88
0A96:  MOVWF  xF1
....................       }  
....................      #endif  
....................  
....................       //set BC8 and BC9  
....................       if (bit_test(len,8)) {bit_set(i,0);}  
0A98:  BTFSC  xEF.0
0A9A:  BSF    xF1.0
....................       if (bit_test(len,9)) {bit_set(i,1);}  
0A9C:  BTFSC  xEF.1
0A9E:  BSF    xF1.1
....................  
....................       debug_usb(debug_putc," %X",i);  
....................  
....................       EP_BDxST_I(endpoint)=i;//save changes  
0AA0:  MOVF   xED,W
0AA2:  MULLW  08
0AA4:  MOVF   FF3,W
0AA6:  ADDLW  04
0AA8:  MOVWF  01
0AAA:  MOVLW  04
0AAC:  MOVWF  03
0AAE:  BTFSC  FD8.0
0AB0:  INCF   03,F
0AB2:  MOVFF  01,FE9
0AB6:  MOVFF  03,FEA
0ABA:  MOVFF  F1,FEF
....................  
....................       return(1);  
0ABE:  MOVLW  01
0AC0:  MOVWF  01
0AC2:  BRA    0ACA
....................    }  
....................     else {  
0AC4:  BRA    0AC6
....................          debug_usb(debug_putc,"\r\nPUT ERR");  
....................     }  
....................    return(0);  
0AC6:  MOVLW  00
0AC8:  MOVWF  01
.................... }  
0ACA:  RETLW  00
....................  
.................... /*******************************************************************************  
.................... /* usb_put_packet(endpoint,*ptr,len,toggle)  
.................... /*  
.................... /* Input: endpoint - endpoint to send packet to  
.................... /*        ptr - points to data to send  
.................... /*        len - amount of data to send  
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid, or toggle from the last DATAx pid.  
.................... /*  
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only reason it will  
.................... /*         return FALSE is if because the TX buffer is still full from the last time you  
.................... /*         tried to send a packet.  
.................... /*  
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a difference  
.................... /*          between a packet and a message.  If you wanted to send a 512 byte message you  
.................... /*          would accomplish this by sending 8 64-byte packets, followed by a 0 length packet.  
.................... /*          If the last (or only packet) being sent is less than the max packet size defined  
.................... /*          in your descriptor then you do not need to send a 0 length packet to identify  
.................... /*          an end of message.  
.................... /*  
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message correctly.  
.................... /*  
.................... /********************************************************************************/  
.................... int1 usb_put_packet(int8 endpoint, int8 * ptr, int16 len, USB_DTS_BIT tgl) { //done  
....................    int16 j;  
....................    int8 i;  
....................    int8 * buff_add;     
....................  
....................    i=EP_BDxST_I(endpoint);  
*
0E8C:  MOVF   xD6,W
0E8E:  MULLW  08
0E90:  MOVF   FF3,W
0E92:  ADDLW  04
0E94:  MOVWF  01
0E96:  MOVLW  04
0E98:  MOVWF  03
0E9A:  BTFSC  FD8.0
0E9C:  INCF   03,F
0E9E:  MOVFF  01,FE9
0EA2:  MOVFF  03,FEA
0EA6:  MOVFF  FEF,DE
....................    if (!bit_test(i,7)) {  
0EAA:  BTFSC  xDE.7
0EAC:  BRA    0F38
....................  
....................       buff_add=EP_BDxADR_I(endpoint);  
0EAE:  MOVF   xD6,W
0EB0:  MULLW  08
0EB2:  MOVF   FF3,W
0EB4:  ADDLW  06
0EB6:  MOVWF  01
0EB8:  MOVLW  04
0EBA:  MOVWF  03
0EBC:  BTFSC  FD8.0
0EBE:  INCF   03,F
0EC0:  MOVFF  01,FE9
0EC4:  MOVFF  03,FEA
0EC8:  MOVFF  FEC,03
0ECC:  MOVF   FED,F
0ECE:  MOVFF  FEF,DF
0ED2:  MOVFF  03,E0
....................  
....................       for (j=0;j<len;j++) {  
0ED6:  CLRF   xDD
0ED8:  CLRF   xDC
0EDA:  MOVF   xDD,W
0EDC:  SUBWF  xDA,W
0EDE:  BNC   0F14
0EE0:  BNZ   0EE8
0EE2:  MOVF   xD9,W
0EE4:  SUBWF  xDC,W
0EE6:  BC    0F14
....................          *buff_add=*ptr;  
0EE8:  MOVFF  D7,FE9
0EEC:  MOVFF  D8,FEA
0EF0:  MOVFF  FEF,E3
0EF4:  MOVFF  E0,FEA
0EF8:  MOVFF  DF,FE9
0EFC:  MOVFF  E3,FEF
....................          buff_add++;  
0F00:  INCF   xDF,F
0F02:  BTFSC  FD8.2
0F04:  INCF   xE0,F
....................          ptr++;  
0F06:  INCF   xD7,F
0F08:  BTFSC  FD8.2
0F0A:  INCF   xD8,F
....................       }  
0F0C:  INCF   xDC,F
0F0E:  BTFSC  FD8.2
0F10:  INCF   xDD,F
0F12:  BRA    0EDA
0F14:  CLRF   18
0F16:  BTFSC  FF2.7
0F18:  BSF    18.7
0F1A:  BCF    FF2.7
....................  
....................       return(usb_flush_in(endpoint, len, tgl));  
0F1C:  MOVFF  D6,ED
0F20:  MOVFF  DA,EF
0F24:  MOVFF  D9,EE
0F28:  MOVFF  DB,F0
0F2C:  RCALL  09EE
0F2E:  BTFSC  18.7
0F30:  BSF    FF2.7
0F32:  MOVF   01,W
0F34:  BRA    0F3C
....................     }  
....................     else {  
0F36:  BRA    0F38
....................         debug_usb(debug_putc,"\r\nPUT ERR");  
....................     }  
....................     return(0);  
0F38:  MOVLW  00
0F3A:  MOVWF  01
.................... }  
0F3C:  RETLW  00
....................  
.................... /// END User Functions  
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB.C  
....................  
.................... /**************************************************************  
.................... /* usb_flush_out()  
.................... /*  
.................... /* Input: endpoint - which endpoint to mark for transfer  
.................... /*        tgl - Data toggle synchronization to expect in the next packet  
.................... /*  
.................... /* Output: NONE  
.................... /*  
.................... /* Summary: Clears the previously received packet, and then marks this  
.................... /*          endpoint's receive buffer as ready for more data.  
.................... /*          (OUT is PC -> PIC)  
.................... /***************************************************************/  
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl) {  
....................    int8 i;  
....................    int16 len;  
....................  
....................      #if USB_IGNORE_RX_DTS  
....................       if (tgl == USB_DTS_STALL) {  
....................          debug_usb(debug_putc, '*');  
....................          i=0x84;  
....................          EP_BDxST_I(endpoint)=0x84;  
....................          return;  
....................       }  
....................       else  
....................          i=0x80;  
....................      #else  
....................       i=EP_BDxST_O(endpoint);  
*
0908:  MOVF   xED,W
090A:  MULLW  08
090C:  MOVFF  FF3,01
0910:  MOVLW  04
0912:  MOVFF  01,FE9
0916:  MOVWF  FEA
0918:  MOVFF  FEF,EF
....................       if (tgl == USB_DTS_TOGGLE) {  
091C:  MOVF   xEE,W
091E:  SUBLW  02
0920:  BNZ   092E
....................          if (bit_test(i,6))  
0922:  BTFSS  xEF.6
0924:  BRA    092A
....................             tgl=USB_DTS_DATA0;  //was DATA1, goto DATA0  
0926:  CLRF   xEE
....................          else  
0928:  BRA    092E
....................             tgl=USB_DTS_DATA1;  //was DATA0, goto DATA1  
092A:  MOVLW  01
092C:  MOVWF  xEE
....................       }  
....................       if (tgl == USB_DTS_STALL) {  
092E:  MOVF   xEE,W
0930:  SUBLW  03
0932:  BNZ   0958
....................          i=0x84;  
0934:  MOVLW  84
0936:  MOVWF  xEF
....................          EP_BDxST_I(endpoint)=0x84; //stall both in and out endpoints  
0938:  MOVF   xED,W
093A:  MULLW  08
093C:  MOVF   FF3,W
093E:  ADDLW  04
0940:  MOVWF  01
0942:  MOVLW  04
0944:  MOVWF  03
0946:  BTFSC  FD8.0
0948:  INCF   03,F
094A:  MOVFF  01,FE9
094E:  MOVFF  03,FEA
0952:  MOVLW  84
0954:  MOVWF  FEF
....................       }  
....................       else if (tgl == USB_DTS_DATA1) {  
0956:  BRA    096A
0958:  DECFSZ xEE,W
095A:  BRA    0962
....................          i=0xC8;  //DATA1, UOWN  
095C:  MOVLW  C8
095E:  MOVWF  xEF
....................       }  
....................       else if (tgl == USB_DTS_DATA0) {  
0960:  BRA    096A
0962:  MOVF   xEE,F
0964:  BNZ   096A
....................          i=0x88; //DATA0, UOWN  
0966:  MOVLW  88
0968:  MOVWF  xEF
....................       }  
....................      #endif  
....................  
....................    bit_clear(__usb_kbhit_status,endpoint);  
096A:  CLRF   03
096C:  MOVLW  01
096E:  MOVWF  02
0970:  MOVF   xED,W
0972:  MOVWF  00
0974:  BZ    0980
0976:  BCF    FD8.0
0978:  RLCF   02,F
097A:  RLCF   03,F
097C:  DECFSZ 00,F
097E:  BRA    0976
0980:  MOVF   02,W
0982:  XORLW  FF
0984:  MOVWF  00
0986:  MOVLW  FF
0988:  XORWF  03,F
098A:  MOVF   00,W
098C:  ANDWF  1D,F
098E:  MOVF   03,W
0990:  ANDWF  1E,F
....................  
....................    len=usb_ep_rx_size[endpoint];  
0992:  BCF    FD8.0
0994:  RLCF   xED,W
0996:  CLRF   03
0998:  MOVFF  FF2,F2
099C:  BCF    FF2.7
099E:  CALL   00BE
09A2:  TBLRD*+
09A4:  MOVFF  FF5,03
09A8:  BTFSC  xF2.7
09AA:  BSF    FF2.7
09AC:  MOVWF  xF0
09AE:  MOVFF  03,F1
....................    EP_BDxCNT_O(endpoint)=len;  
09B2:  MOVF   xED,W
09B4:  MULLW  08
09B6:  MOVF   FF3,W
09B8:  ADDLW  01
09BA:  MOVWF  01
09BC:  MOVLW  04
09BE:  MOVWF  03
09C0:  BTFSC  FD8.0
09C2:  INCF   03,F
09C4:  MOVFF  01,FE9
09C8:  MOVFF  03,FEA
09CC:  MOVFF  F0,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);}  
09D0:  BTFSC  xF1.0
09D2:  BSF    xEF.0
....................    if (bit_test(len,9)) {bit_set(i,1);}  
09D4:  BTFSC  xF1.1
09D6:  BSF    xEF.1
....................  
....................  
....................    EP_BDxST_O(endpoint)=i;  
09D8:  MOVF   xED,W
09DA:  MULLW  08
09DC:  MOVFF  FF3,01
09E0:  MOVLW  04
09E2:  MOVFF  01,FE9
09E6:  MOVWF  FEA
09E8:  MOVFF  EF,FEF
.................... }  
09EC:  RETLW  00
....................  
.................... int16 usb_rx_packet_size(int8 endpoint) {  
....................    return(EP_BDxCNT_O(endpoint));  
.................... }  
....................  
.................... /*******************************************************************************  
.................... /* usb_get_packet_buffer(endpoint, *ptr, max)  
.................... /*  
.................... /* Input: endpoint - endpoint to get data from  
.................... /*        ptr - where to save data to local PIC RAM  
.................... /*        max - max amount of data to receive from buffer  
.................... /*  
.................... /* Output: the amount of data taken from the buffer.  
.................... /*  
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC RAM.  
.................... /*          Does not mark the endpoint as ready for more data.  Once you are  
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready  
.................... /*          to receive more data.  
.................... /*  
.................... /********************************************************************************/  
.................... int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max)  
.................... { 
....................    int8 * al;  
....................    int8 st;  
....................    int16 i;  
....................  
....................    al=EP_BDxADR_O(endpoint);  
*
10B0:  MOVF   xDB,W
10B2:  MULLW  08
10B4:  MOVF   FF3,W
10B6:  ADDLW  02
10B8:  MOVWF  01
10BA:  MOVLW  04
10BC:  MOVWF  03
10BE:  BTFSC  FD8.0
10C0:  INCF   03,F
10C2:  MOVFF  01,FE9
10C6:  MOVFF  03,FEA
10CA:  MOVFF  FEC,03
10CE:  MOVF   FED,F
10D0:  MOVFF  FEF,E0
10D4:  MOVFF  03,E1
....................    i=EP_BDxCNT_O(endpoint);  
10D8:  MOVF   xDB,W
10DA:  MULLW  08
10DC:  MOVF   FF3,W
10DE:  ADDLW  01
10E0:  MOVWF  01
10E2:  MOVLW  04
10E4:  MOVWF  03
10E6:  BTFSC  FD8.0
10E8:  INCF   03,F
10EA:  MOVFF  01,FE9
10EE:  MOVFF  03,FEA
10F2:  MOVF   FEF,W
10F4:  CLRF   03
10F6:  MOVWF  xE3
10F8:  MOVFF  03,E4
....................    st=EP_BDxST_O(endpoint);  
10FC:  MOVF   xDB,W
10FE:  MULLW  08
1100:  MOVFF  FF3,01
1104:  MOVLW  04
1106:  MOVFF  01,FE9
110A:  MOVWF  FEA
110C:  MOVFF  FEF,E2
....................  
....................    //read BC8 and BC9  
....................    if (bit_test(st,0)) {bit_set(i,8);}  
1110:  BTFSC  xE2.0
1112:  BSF    xE4.0
....................    if (bit_test(st,1)) {bit_set(i,9);}  
1114:  BTFSC  xE2.1
1116:  BSF    xE4.1
....................  
....................    if(i<max) { max=i; }  
1118:  MOVF   xE4,W
111A:  SUBWF  xDF,W
111C:  BNC   112E
111E:  BNZ   1126
1120:  MOVF   xDE,W
1122:  SUBWF  xE3,W
1124:  BC    112E
1126:  MOVFF  E4,DF
112A:  MOVFF  E3,DE
....................  
....................    i=0;  
112E:  CLRF   xE4
1130:  CLRF   xE3
....................  
....................    while (i<max) {  
1132:  MOVF   xE4,W
1134:  SUBWF  xDF,W
1136:  BNC   116C
1138:  BNZ   1140
113A:  MOVF   xDE,W
113C:  SUBWF  xE3,W
113E:  BC    116C
....................       *ptr=*al;  
1140:  MOVFF  E0,FE9
1144:  MOVFF  E1,FEA
1148:  MOVFF  FEF,E7
114C:  MOVFF  DD,FEA
1150:  MOVFF  DC,FE9
1154:  MOVFF  E7,FEF
....................        ptr++;  
1158:  INCF   xDC,F
115A:  BTFSC  FD8.2
115C:  INCF   xDD,F
....................        al++;  
115E:  INCF   xE0,F
1160:  BTFSC  FD8.2
1162:  INCF   xE1,F
....................        i++;  
1164:  INCF   xE3,F
1166:  BTFSC  FD8.2
1168:  INCF   xE4,F
....................    }  
116A:  BRA    1132
....................  
....................    return(max);  
116C:  MOVFF  DE,01
1170:  MOVFF  DF,02
.................... }  
1174:  GOTO   118E (RETURN)
....................  
.................... /*******************************************************************************  
.................... /* usb_get_packet(endpoint, *ptr, max)  
.................... /*  
.................... /* Input: endpoint - endpoint to get data from  
.................... /*        ptr - where to save data to local PIC RAM  
.................... /*        max - max amount of data to receive from buffer  
.................... /*  
.................... /* Output: the amount of data taken from the buffer.  
.................... /*  
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS!  
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()!  
.................... /*  
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC RAM.  
.................... /*          Until you call usb_get_packet() the data will sit in the endpoint  
.................... /*          buffer and the PC will get NAKs when it tries to write more data  
.................... /*          to the endpoint.  
.................... /*  
.................... /********************************************************************************/  
.................... int16 usb_get_packet(int8 endpoint, int8 * ptr, int16 max) {  
....................  
....................    max=usb_get_packet_buffer(endpoint,ptr,max);  
1178:  MOVFF  D6,DB
117C:  MOVFF  D8,DD
1180:  MOVFF  D7,DC
1184:  MOVFF  DA,DF
1188:  MOVFF  D9,DE
118C:  BRA    10B0
118E:  MOVFF  02,DA
1192:  MOVFF  01,D9
1196:  CLRF   18
1198:  BTFSC  FF2.7
119A:  BSF    18.7
119C:  BCF    FF2.7
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE);  
119E:  MOVFF  D6,ED
11A2:  MOVLW  02
11A4:  MOVWF  xEE
11A6:  CALL   0908
11AA:  BTFSC  18.7
11AC:  BSF    FF2.7
....................  
....................    return(max);  
11AE:  MOVFF  D9,01
11B2:  MOVFF  DA,02
.................... }  
11B6:  RETLW  00
....................  
.................... /*******************************************************************************  
.................... /* usb_tbe(endpoint)  
.................... /*  
.................... /* Input: endpoint - endpoint to check  
.................... /*        ptr - where to save data to local PIC RAM  
.................... /*        max - max amount of data to receive from buffer  
.................... /*  
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready  
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last  
.................... /*         transmit or if this endpoint is invalid.  
.................... /*  
.................... /********************************************************************************/  
.................... int8 usb_tbe(int8 endpoint) {  
....................    int8 st;  
....................    st=EP_BDxST_I(endpoint);  
....................    if (!bit_test(st,7))  
....................       return(TRUE);  
....................    return(FALSE);  
.................... }  
....................  
.................... /*******************************************************************************  
.................... /* usb_stall_ep(endpoint,direction)  
.................... /*  
.................... /* Input: endpoint - endpoint to stall.  
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)  
.................... /*  
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will send STALL packet  
.................... /*          if the host tries to access this endpoint's buffer.  
.................... /*  
.................... /*  
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK THIS  
.................... /*  
.................... /********************************************************************************/  
.................... void usb_stall_ep(int8 endpoint) {  //done  
....................    int1 direction;  
....................    direction=bit_test(endpoint,7);  
*
07D6:  BCF    xEE.0
07D8:  BTFSC  xED.7
07DA:  BSF    xEE.0
....................    endpoint&=0x7F;  
07DC:  BCF    xED.7
....................    if (direction) {  
07DE:  BTFSS  xEE.0
07E0:  BRA    0802
....................       EP_BDxST_I(endpoint)=0x84;  
07E2:  MOVF   xED,W
07E4:  MULLW  08
07E6:  MOVF   FF3,W
07E8:  ADDLW  04
07EA:  MOVWF  01
07EC:  MOVLW  04
07EE:  MOVWF  03
07F0:  BTFSC  FD8.0
07F2:  INCF   03,F
07F4:  MOVFF  01,FE9
07F8:  MOVFF  03,FEA
07FC:  MOVLW  84
07FE:  MOVWF  FEF
....................    }  
....................    else {  
0800:  BRA    0816
....................       EP_BDxST_O(endpoint)=0x84;  
0802:  MOVF   xED,W
0804:  MULLW  08
0806:  MOVFF  FF3,01
080A:  MOVLW  04
080C:  MOVFF  01,FE9
0810:  MOVWF  FEA
0812:  MOVLW  84
0814:  MOVWF  FEF
....................    }  
.................... }  
0816:  GOTO   089E (RETURN)
....................  
.................... /*******************************************************************************  
.................... /* usb_unstall_ep(endpoint, direction)  
.................... /*  
.................... /* Input: endpoint - endpoint to un-stall.  
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)  
.................... /*  
.................... /* Summary: Un-stalls endpoint.  
.................... /*  
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK THIS  
.................... /********************************************************************************/  
.................... void usb_unstall_ep(int8 endpoint) {   //done  
....................    int1 direction;  
....................    direction=bit_test(endpoint,7);  
*
0794:  BCF    xEE.0
0796:  BTFSC  xED.7
0798:  BSF    xEE.0
....................    endpoint&=0x7F;  
079A:  BCF    xED.7
....................    if (direction) {  
079C:  BTFSS  xEE.0
079E:  BRA    07C0
....................       #if USB_IGNORE_RX_DTS  
....................       EP_BDxST_I(endpoint)=0x80;  
....................       #else  
....................       EP_BDxST_I(endpoint)=0x88;  
07A0:  MOVF   xED,W
07A2:  MULLW  08
07A4:  MOVF   FF3,W
07A6:  ADDLW  04
07A8:  MOVWF  01
07AA:  MOVLW  04
07AC:  MOVWF  03
07AE:  BTFSC  FD8.0
07B0:  INCF   03,F
07B2:  MOVFF  01,FE9
07B6:  MOVFF  03,FEA
07BA:  MOVLW  88
07BC:  MOVWF  FEF
....................       #endif  
....................    }  
....................    else {  
07BE:  BRA    07D2
....................       EP_BDxST_O(endpoint)=0x00;  
07C0:  MOVF   xED,W
07C2:  MULLW  08
07C4:  MOVFF  FF3,01
07C8:  MOVLW  04
07CA:  MOVFF  01,FE9
07CE:  MOVWF  FEA
07D0:  CLRF   FEF
....................    }  
.................... }  
07D2:  GOTO   0892 (RETURN)
....................  
.................... /*******************************************************************************  
.................... /* usb_endpoint_stalled(endpoint)  
.................... /*  
.................... /* Input: endpoint - endpoint to check  
.................... /*                   top most bit indicates direction (set is IN, clear is OUT)  
.................... /*  
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not.  
.................... /*  
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to  
.................... /*          see if endpoint has been issued a STALL, just whether or not it is  
.................... /*          configured to STALL on the next packet.  See Set_Feature and Clear_Feature  
.................... /*          Chapter 9 requests.  
.................... /*  
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK THIS  
.................... /********************************************************************************/  
.................... int1 usb_endpoint_stalled(int8 endpoint) {   //done  
....................    int1 direction;  
....................    int8 st;  
....................    direction=bit_test(endpoint,7);  
*
081A:  BCF    xEE.0
081C:  BTFSC  xED.7
081E:  BSF    xEE.0
....................    endpoint&=0x7F;  
0820:  BCF    xED.7
....................    if (direction) {  
0822:  BTFSS  xEE.0
0824:  BRA    0846
....................       st=EP_BDxST_I(endpoint);  
0826:  MOVF   xED,W
0828:  MULLW  08
082A:  MOVF   FF3,W
082C:  ADDLW  04
082E:  MOVWF  01
0830:  MOVLW  04
0832:  MOVWF  03
0834:  BTFSC  FD8.0
0836:  INCF   03,F
0838:  MOVFF  01,FE9
083C:  MOVFF  03,FEA
0840:  MOVFF  FEF,EF
....................    }  
....................    else {  
0844:  BRA    085A
....................       st=EP_BDxST_O(endpoint);  
0846:  MOVF   xED,W
0848:  MULLW  08
084A:  MOVFF  FF3,01
084E:  MOVLW  04
0850:  MOVFF  01,FE9
0854:  MOVWF  FEA
0856:  MOVFF  FEF,EF
....................    }  
....................    return(bit_test(st,7) && bit_test(st,2));  
085A:  BTFSS  xEF.7
085C:  BRA    0862
085E:  BTFSC  xEF.2
0860:  BRA    0866
0862:  MOVLW  00
0864:  BRA    0868
0866:  MOVLW  01
0868:  MOVWF  01
.................... }  
086A:  GOTO   08B2 (RETURN)
....................  
....................  
.................... /*******************************************************************************  
.................... /* usb_set_address(address)  
.................... /*  
.................... /* Input: address - address the host specified that we use  
.................... /*  
.................... /* Summary: Configures the USB Peripheral for the specified device address.  The host  
.................... /*          will now talk to use with the following address.  
.................... /*  
.................... /********************************************************************************/  
.................... void usb_set_address(int8 address) {   //done  
....................    UADDR=address;  
*
0AF6:  MOVFF  EE,F6E
....................    if (address) {  
0AFA:  MOVF   xEE,F
0AFC:  BZ    0B04
....................       usb_state=USB_STATE_ADDRESS;  
0AFE:  MOVLW  04
0B00:  MOVWF  1F
....................    }  
....................    else {  
0B02:  BRA    0B08
....................       usb_state=USB_STATE_POWERED;  
0B04:  MOVLW  02
0B06:  MOVWF  1F
....................    }  
.................... }  
0B08:  GOTO   0B16 (RETURN)
....................  
....................  
.................... /*******************************************************************************  
.................... /* usb_set_configured(config)  
.................... /*  
.................... /* Input: config - Configuration to use.  0 to uncofigure device.  
.................... /*  
.................... /* Summary: Configures or unconfigures device.  If configuring device it will  
.................... /*          enable all the endpoints the user specified for this configuration.  
.................... /*          If un-configuring device it will disable all endpoints.  
.................... /*  
.................... /*          NOTE: CCS only provides code to handle 1 configuration.  
.................... /*  
.................... /********************************************************************************/  
.................... void usb_set_configured(int config) {  
....................    int8 en;  
....................    int16 addy;  
....................    int8 new_uep;  
....................    int16 len;  
....................    int8 i;  
....................       if (config==0) {  
*
0472:  MOVF   xED,F
0474:  BNZ   047E
....................          //if config=0 then set addressed state  
....................          usb_state=USB_STATE_ADDRESS;  
0476:  MOVLW  04
0478:  MOVWF  1F
....................          usb_disable_endpoints();  
047A:  RCALL  022E
....................       }  
....................       else {  
047C:  BRA    0600
....................          usb_state=USB_STATE_CONFIGURED; //else set configed state  
047E:  MOVLW  05
0480:  MOVWF  1F
....................          addy=(int16)USB_BUFFER+(2*USB_MAX_EP0_PACKET_LENGTH);  
0482:  MOVWF  xF0
0484:  MOVLW  80
0486:  MOVWF  xEF
....................          for (en=1;en<16;en++) {  
0488:  MOVLW  01
048A:  MOVWF  xEE
048C:  MOVF   xEE,W
048E:  SUBLW  0F
0490:  BTFSS  FD8.0
0492:  BRA    0600
....................             new_uep=0;  
0494:  CLRF   xF1
....................             if (usb_ep_rx_type[en]!=USB_ENABLE_DISABLED) {  
0496:  CLRF   03
0498:  MOVF   xEE,W
049A:  MOVFF  FF2,F5
049E:  BCF    FF2.7
04A0:  RCALL  009E
04A2:  BTFSC  xF5.7
04A4:  BSF    FF2.7
04A6:  XORLW  00
04A8:  BZ    054C
....................                new_uep=0x04;  
04AA:  MOVLW  04
04AC:  MOVWF  xF1
....................                len=usb_ep_rx_size[en];  
04AE:  BCF    FD8.0
04B0:  RLCF   xEE,W
04B2:  CLRF   03
04B4:  MOVFF  FF2,F5
04B8:  BCF    FF2.7
04BA:  RCALL  00BE
04BC:  TBLRD*+
04BE:  MOVFF  FF5,03
04C2:  BTFSC  xF5.7
04C4:  BSF    FF2.7
04C6:  MOVWF  xF2
04C8:  MOVFF  03,F3
....................                EP_BDxCNT_O(en)=len;  
04CC:  MOVF   xEE,W
04CE:  MULLW  08
04D0:  MOVF   FF3,W
04D2:  ADDLW  01
04D4:  MOVWF  01
04D6:  MOVLW  04
04D8:  MOVWF  03
04DA:  BTFSC  FD8.0
04DC:  INCF   03,F
04DE:  MOVFF  01,FE9
04E2:  MOVFF  03,FEA
04E6:  MOVFF  F2,FEF
....................                EP_BDxADR_O(en)=addy;  
04EA:  MOVF   xEE,W
04EC:  MULLW  08
04EE:  MOVF   FF3,W
04F0:  ADDLW  02
04F2:  MOVWF  01
04F4:  MOVLW  04
04F6:  MOVWF  03
04F8:  BTFSC  FD8.0
04FA:  INCF   03,F
04FC:  MOVFF  01,FE9
0500:  MOVFF  03,FEA
0504:  MOVFF  F0,FEC
0508:  MOVF   FED,F
050A:  MOVFF  EF,FEF
....................                addy+=usb_ep_rx_size[en];  
050E:  BCF    FD8.0
0510:  RLCF   xEE,W
0512:  CLRF   03
0514:  MOVFF  FF2,F5
0518:  BCF    FF2.7
051A:  RCALL  00BE
051C:  TBLRD*+
051E:  MOVFF  FF5,03
0522:  BTFSC  xF5.7
0524:  BSF    FF2.7
0526:  ADDWF  xEF,F
0528:  MOVF   03,W
052A:  ADDWFC xF0,F
....................                #if USB_IGNORE_RX_DTS  
....................                   i=0x80;  
....................                #else  
....................                   i=0x88;  
052C:  MOVLW  88
052E:  MOVWF  xF4
....................                #endif  
....................                if (bit_test(len,8)) {bit_set(i,0);}  
0530:  BTFSC  xF3.0
0532:  BSF    xF4.0
....................                if (bit_test(len,9)) {bit_set(i,1);}  
0534:  BTFSC  xF3.1
0536:  BSF    xF4.1
....................                EP_BDxST_O(en)=i;  
0538:  MOVF   xEE,W
053A:  MULLW  08
053C:  MOVFF  FF3,01
0540:  MOVLW  04
0542:  MOVFF  01,FE9
0546:  MOVWF  FEA
0548:  MOVFF  F4,FEF
....................             }  
....................             if (usb_ep_tx_type[en]!=USB_ENABLE_DISABLED) {  
054C:  CLRF   03
054E:  MOVF   xEE,W
0550:  MOVFF  FF2,F5
0554:  BCF    FF2.7
0556:  RCALL  009E
0558:  BTFSC  xF5.7
055A:  BSF    FF2.7
055C:  XORLW  00
055E:  BZ    05C2
....................                new_uep|=0x02;  
0560:  BSF    xF1.1
....................                EP_BDxADR_I(en)=addy;  
0562:  MOVF   xEE,W
0564:  MULLW  08
0566:  MOVF   FF3,W
0568:  ADDLW  06
056A:  MOVWF  01
056C:  MOVLW  04
056E:  MOVWF  03
0570:  BTFSC  FD8.0
0572:  INCF   03,F
0574:  MOVFF  01,FE9
0578:  MOVFF  03,FEA
057C:  MOVFF  F0,FEC
0580:  MOVF   FED,F
0582:  MOVFF  EF,FEF
....................                addy+=usb_ep_tx_size[en];  
0586:  BCF    FD8.0
0588:  RLCF   xEE,W
058A:  CLRF   03
058C:  MOVFF  FF2,F5
0590:  BCF    FF2.7
0592:  RCALL  00BE
0594:  TBLRD*+
0596:  MOVFF  FF5,03
059A:  BTFSC  xF5.7
059C:  BSF    FF2.7
059E:  ADDWF  xEF,F
05A0:  MOVF   03,W
05A2:  ADDWFC xF0,F
....................                EP_BDxST_I(en)=0x40;  
05A4:  MOVF   xEE,W
05A6:  MULLW  08
05A8:  MOVF   FF3,W
05AA:  ADDLW  04
05AC:  MOVWF  01
05AE:  MOVLW  04
05B0:  MOVWF  03
05B2:  BTFSC  FD8.0
05B4:  INCF   03,F
05B6:  MOVFF  01,FE9
05BA:  MOVFF  03,FEA
05BE:  MOVLW  40
05C0:  MOVWF  FEF
....................             }  
....................             if (new_uep==0x06) {new_uep=0x0E;}  
05C2:  MOVF   xF1,W
05C4:  SUBLW  06
05C6:  BNZ   05CC
05C8:  MOVLW  0E
05CA:  MOVWF  xF1
....................             if (usb_ep_tx_type[en]!=USB_ENABLE_ISOCHRONOUS) {  
05CC:  CLRF   03
05CE:  MOVF   xEE,W
05D0:  MOVFF  FF2,F5
05D4:  BCF    FF2.7
05D6:  RCALL  009E
05D8:  BTFSC  xF5.7
05DA:  BSF    FF2.7
05DC:  SUBLW  02
05DE:  BZ    05E2
....................                new_uep|=0x10;  
05E0:  BSF    xF1.4
....................             }  
....................             UEP(en)=new_uep;  
05E2:  MOVLW  70
05E4:  ADDWF  xEE,W
05E6:  MOVWF  01
05E8:  MOVLW  0F
05EA:  MOVWF  03
05EC:  BTFSC  FD8.0
05EE:  INCF   03,F
05F0:  MOVFF  01,FE9
05F4:  MOVFF  03,FEA
05F8:  MOVFF  F1,FEF
....................          }  
05FC:  INCF   xEE,F
05FE:  BRA    048C
....................       }  
.................... }  
0600:  GOTO   0698 (RETURN)
....................  
.................... /// END Hardware layer functions required by USB.C  
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine  
....................  
.................... /*******************************************************************************  
.................... /* usb_handle_interrupt()  
.................... /*  
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished  
.................... /*          tokens is the majority of this code, and is handled by usb.c  
.................... /*  
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt method),  
.................... /*       then you must call this function rapidly.  If there is more than 10ms  
.................... /*       latency the PC may think the USB device is stalled and disable it.  
.................... /*       To switch to a polling method, remove the #int_usb line above this fuction.  
.................... /*       Also, goto usb_init() and remove the code that enables the USB interrupt.  
.................... /********************************************************************************/  
.................... #int_usb  
.................... void usb_isr() {  
....................    if (usb_state==USB_STATE_DETACHED) return;   //should never happen, though  
*
0BFC:  MOVF   1F,F
0BFE:  BNZ   0C02
0C00:  BRA    0C60
....................    if (UIR) {  
0C02:  MOVF   F68,F
0C04:  BZ    0C60
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR);  
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();}  //activity detected.  (only enable after sleep)  
0C06:  BTFSS  F68.2
0C08:  BRA    0C12
0C0A:  BTFSS  F69.2
0C0C:  BRA    0C12
0C0E:  GOTO   01F8
....................  
....................       if (UCON_SUSPND) return;  
0C12:  BTFSS  F6D.1
0C14:  BRA    0C18
0C16:  BRA    0C60
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected  
0C18:  BTFSS  F68.1
0C1A:  BRA    0C24
0C1C:  BTFSS  F69.1
0C1E:  BRA    0C24
0C20:  GOTO   0202
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected  
0C24:  BTFSS  F68.0
0C26:  BRA    0C30
0C28:  BTFSS  F69.0
0C2A:  BRA    0C30
0C2C:  GOTO   0278
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep  
0C30:  BTFSS  F68.4
0C32:  BRA    0C3C
0C34:  BTFSS  F69.4
0C36:  BRA    0C3C
0C38:  GOTO   02A2
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();}  
0C3C:  BTFSS  F68.6
0C3E:  BRA    0C48
0C40:  BTFSS  F69.6
0C42:  BRA    0C48
0C44:  GOTO   02AC
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent  
0C48:  BTFSS  F68.5
0C4A:  BRA    0C54
0C4C:  BTFSS  F69.5
0C4E:  BRA    0C54
0C50:  GOTO   02B2
....................  
....................       if (UIR_TRN && UIE_TRN) {  
0C54:  BTFSS  F68.3
0C56:  BRA    0C60
0C58:  BTFSS  F69.3
0C5A:  BRA    0C60
....................          usb_isr_tok_dne();  
0C5C:  BRA    0B32
....................          UIR_TRN=0;    // clear the token done interrupt., 0x190.3  
0C5E:  BCF    F68.3
....................       }    //a token has been detected (majority of isrs)  
....................    }  
.................... }  
....................  
.................... //SOF interrupt not handled.  user must add this depending on application  
0C60:  BCF    FA1.5
0C62:  GOTO   0058
.................... void usb_isr_sof(void) {  
....................    debug_usb(debug_putc,"\r\nSOF");  
....................    UIR_SOF=0;  
*
02AC:  BCF    F68.6
.................... }  
02AE:  GOTO   0C48 (RETURN)
....................  
.................... /*******************************************************************************  
.................... /* usb_disable_endpoints()  
.................... /*  
.................... /* Summary: Disables endpoints 1 thru 15  
.................... /*  
.................... /********************************************************************************/  
.................... void usb_disable_endpoints(void) {  
....................    int8 i;  
....................    for (i=1;i<16;i++) {  
*
022E:  MOVLW  01
0230:  MOVWF  xF5
0232:  MOVF   xF5,W
0234:  SUBLW  0F
0236:  BNC   0254
....................       UEP(i)=ENDPT_DISABLED;  
0238:  MOVLW  70
023A:  ADDWF  xF5,W
023C:  MOVWF  01
023E:  MOVLW  0F
0240:  MOVWF  03
0242:  BTFSC  FD8.0
0244:  INCF   03,F
0246:  MOVFF  01,FE9
024A:  MOVFF  03,FEA
024E:  CLRF   FEF
....................    }  
0250:  INCF   xF5,F
0252:  BRA    0232
....................    __usb_kbhit_status=0;  
0254:  CLRF   1E
0256:  CLRF   1D
.................... }  
0258:  RETLW  00
....................  
.................... /*******************************************************************************  
.................... /* usb_isr_rst()  
.................... /*  
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device  
.................... /*          and token handler code to initial state.  
.................... /*  
.................... /********************************************************************************/  
.................... void usb_isr_rst() {  
....................    debug_usb(debug_putc,"R");  
....................  
....................    UEIR=0;  
*
0278:  CLRF   F6A
....................    UIR=0;  
027A:  CLRF   F68
....................    UEIE=0x9F;  
027C:  MOVLW  9F
027E:  MOVWF  F6B
....................    UIE=STANDARD_INTS & ~__USB_UIF_ACTIVE;  
0280:  MOVLW  39
0282:  MOVWF  F69
....................  
....................    UADDR=0;  
0284:  CLRF   F6E
....................  
....................    usb_token_reset();  
0286:  RCALL  020A
....................  
....................    usb_disable_endpoints();  
0288:  RCALL  022E
....................  
....................    UEP(0)=ENDPT_CONTROL | 0x10;  
028A:  MOVLW  16
028C:  MOVWF  F70
....................  
....................    while (UIR_TRN) {  
028E:  BTFSS  F68.3
0290:  BRA    0296
....................       UIR_TRN=0;    //do this to clear out the ustat fifo  
0292:  BCF    F68.3
....................    }  
0294:  BRA    028E
....................  
....................    UCON_PKTDIS=0; //SIE token and packet processing enabled  
0296:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup();  
0298:  RCALL  025A
....................  
....................    usb_state=USB_STATE_DEFAULT; //put usb mcu into default state  
029A:  MOVLW  03
029C:  MOVWF  1F
.................... }  
029E:  GOTO   0C30 (RETURN)
....................  
.................... /*****************************************************************************  
.................... /* usb_init_ep0_setup()  
.................... /*  
.................... /* Summary: Configure EP0 to receive setup packets  
.................... /*  
.................... /*****************************************************************************/  
.................... void usb_init_ep0_setup(void) {  
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH;  
*
025A:  MOVLW  40
025C:  MOVLB  4
025E:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_BUFFER;  
0260:  MOVLW  05
0262:  MOVWF  x03
0264:  CLRF   x02
....................    #if USB_IGNORE_RX_DTS  
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off  
....................    #else  
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on  
0266:  MOVLW  88
0268:  MOVWF  x00
....................    #endif  
....................  
....................     EP_BDxST_I(0) = 0;  
026A:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_BUFFER + (int16)USB_MAX_EP0_PACKET_LENGTH;  
026C:  MOVLW  05
026E:  MOVWF  x07
0270:  MOVLW  40
0272:  MOVWF  x06
.................... }  
0274:  MOVLB  0
0276:  RETLW  00
....................  
.................... /*******************************************************************************  
.................... /* usb_isr_uerr()  
.................... /*  
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter  
.................... /*          will incerement.  If having problems check the status of these 8 bytes.  
.................... /*  
.................... /* NOTE: This code is not enabled by default.  
.................... /********************************************************************************/  
.................... void usb_isr_uerr() {  
.................... #if USB_USE_ERROR_COUNTER  
....................    int ints;  
.................... #endif  
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR);  
....................  
.................... #if USB_USE_ERROR_COUNTER  
....................  
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled  
....................  
....................    if ( bit_test(ints,0) ) { //increment pid_error counter  
....................       debug_usb(debug_putc,"PID ");  
....................       ERROR_COUNTER[0]++;  
....................    }  
....................  
....................    if ( bit_test(ints,1) ) {  //increment crc5 error counter  
....................       debug_usbdebug_putc,"CRC5 ");  
....................       ERROR_COUNTER[1]++;  
....................    }  
....................  
....................    if ( bit_test(ints,2) ) {  //increment crc16 error counter  
....................       debug_usb(debug_putc,"CRC16 ");  
....................       ERROR_COUNTER[2]++;  
....................    }  
....................  
....................    if ( bit_test(ints,3) ) {  //increment dfn8 error counter  
....................       debug_usb(debug_putc,"DFN8 ");  
....................       ERROR_COUNTER[3]++;  
....................    }  
....................  
....................    if ( bit_test(ints,4) ) {  //increment bto error counter  
....................       debug_usb(debug_putc,"BTO ");  
....................       ERROR_COUNTER[4]++;  
....................    }  
....................  
....................    if ( bit_test(ints,7) ) { //increment bts error counter  
....................       debug_usb(debug_putc,"BTS ");  
....................       ERROR_COUNTER[5]++;  
....................    }  
.................... #endif  
....................  
....................    UEIR=0;  
*
0202:  CLRF   F6A
....................    UIR_UERR=0;  
0204:  BCF    F68.1
.................... }  
0206:  GOTO   0C24 (RETURN)
....................  
.................... /*******************************************************************************  
.................... /* usb_isr_uidle()  
.................... /*  
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep.  
.................... /*  
.................... /********************************************************************************/  
.................... void usb_isr_uidle() {  
....................    debug_usb(debug_putc,"I");  
....................  
....................    UIE_ACTV=1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice)  
*
02A2:  BSF    F69.2
....................    UIR_IDLE=0; //clear idle interrupt flag  
02A4:  BCF    F68.4
....................    UCON_SUSPND=1; //set suspend. we are now suspended  
02A6:  BSF    F6D.1
.................... }  
02A8:  GOTO   0C3C (RETURN)
....................  
....................  
.................... /*******************************************************************************  
.................... /* usb_isr_activity()  
.................... /*  
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB  
.................... /*          peripheral.  
.................... /*  
.................... /********************************************************************************/  
.................... void usb_isr_activity() {  
....................    debug_usb(debug_putc,"A");  
....................  
....................    UCON_SUSPND=0; //turn off low power suspending  
*
01F8:  BCF    F6D.1
....................    UIE_ACTV=0; //clear activity interupt enabling  
01FA:  BCF    F69.2
....................    UIR_ACTV=0;  
01FC:  BCF    F68.2
.................... }  
01FE:  GOTO   0C12 (RETURN)
....................  
.................... /*******************************************************************************  
.................... /* usb_isr_stall()  
.................... /*  
.................... /* Summary: Stall handshake detected.  
.................... /*  
.................... /********************************************************************************/  
.................... void usb_isr_stall(void) {  
....................    debug_usb(debug_putc,"S");  
....................  
....................    if (bit_test(UEP(0),0)) {  
*
02B2:  BTFSS  F70.0
02B4:  BRA    02BA
....................       usb_init_ep0_setup();  
02B6:  RCALL  025A
....................       bit_clear(UEP(0),0);  
02B8:  BCF    F70.0
....................    }  
....................    UIR_STALL=0;  
02BA:  BCF    F68.5
.................... }  
02BC:  GOTO   0C54 (RETURN)
....................  
....................  
.................... /*******************************************************************************  
.................... /* usb_isr_tok_dne()  
.................... /*  
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral.  
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and  
.................... /*          handle the request.  
.................... /*          If an IN token on EP0 was received, continue transmitting any  
.................... /*          unfinished requests that may take more than one packet to transmit  
.................... /*          (if necessary).  
.................... /*          If an OUT token on any other EP was received, mark that EP as ready  
.................... /*          for a usb_get_packet().  
.................... /*          Does not handle any IN or OUT tokens on EP0.  
.................... /*  
.................... /********************************************************************************/  
.................... void usb_isr_tok_dne() {  
....................    int8 en;  
....................  
....................    en=USTAT>>3;  
*
0B32:  RRCF   F6C,W
0B34:  MOVWF  xEC
0B36:  RRCF   xEC,F
0B38:  RRCF   xEC,F
0B3A:  MOVLW  1F
0B3C:  ANDWF  xEC,F
....................  
....................          debug_usb(debug_putc,"T ");  
....................          debug_usb(debug_putc,"%X ", USTAT);  
....................  
....................       if (USTAT==USTAT_OUT_SETUP_E0) {   //new out or setup token in the buffer  
0B3E:  MOVF   F6C,F
0B40:  BNZ   0BB8
....................          debug_usb(debug_putc,"%X ", EP_BDxST_O(0));  
....................          if ((EP_BDxST_O(0) & 0x3C)==USB_PIC_PID_SETUP) {  
0B42:  MOVLB  4
0B44:  MOVF   x00,W
0B46:  ANDLW  3C
0B48:  SUBLW  34
0B4A:  BNZ   0B82
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests)  
0B4C:  CLRF   x04
....................  
....................             debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0));  
....................             debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer);  
....................  
....................             usb_isr_tok_setup_dne();  
0B4E:  MOVLB  0
0B50:  BRA    08DE
....................  
....................             //if setup_0_tx_size==0xFF - stall ep0 (unhandled request)  
....................             //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone  
....................             //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit  
....................             if (__setup_0_tx_size==0xFF)  
0B52:  INCFSZ 20,W
0B54:  BRA    0B60
....................                usb_flush_out(0,USB_DTS_STALL);  
0B56:  CLRF   xED
0B58:  MOVLW  03
0B5A:  MOVWF  xEE
0B5C:  RCALL  0908
....................             else {  
0B5E:  BRA    0B7C
....................                usb_flush_out(0,USB_DTS_TOGGLE);  
0B60:  CLRF   xED
0B62:  MOVLW  02
0B64:  MOVWF  xEE
0B66:  RCALL  0908
....................                if (__setup_0_tx_size!=0xFE) {  
0B68:  MOVF   20,W
0B6A:  SUBLW  FE
0B6C:  BZ    0B7C
....................                   usb_flush_in(0,__setup_0_tx_size,USB_DTS_USERX);  
0B6E:  CLRF   xED
0B70:  CLRF   xEF
0B72:  MOVFF  20,EE
0B76:  MOVLW  04
0B78:  MOVWF  xF0
0B7A:  RCALL  09EE
....................                }  
....................             }  
....................             UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit  
0B7C:  BCF    F6D.4
....................          }  
....................          else if ((EP_BDxST_O(0) & 0x3C)==USB_PIC_PID_OUT) {  
0B7E:  BRA    0BB2
0B80:  MOVLB  4
0B82:  MOVF   x00,W
0B84:  ANDLW  3C
0B86:  SUBLW  04
0B88:  BNZ   0BB4
....................             usb_isr_tok_out_dne(0);  
0B8A:  MOVLB  0
0B8C:  CLRF   xED
0B8E:  RCALL  0ACC
....................             usb_flush_out(0,USB_DTS_TOGGLE);  
0B90:  CLRF   xED
0B92:  MOVLW  02
0B94:  MOVWF  xEE
0B96:  RCALL  0908
....................             if ((__setup_0_tx_size!=0xFE)&&(__setup_0_tx_size!=0xFF)) {  
0B98:  MOVF   20,W
0B9A:  SUBLW  FE
0B9C:  BZ    0BB2
0B9E:  INCFSZ 20,W
0BA0:  BRA    0BA4
0BA2:  BRA    0BB2
....................                usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len)  
0BA4:  CLRF   xED
0BA6:  CLRF   xEF
0BA8:  MOVFF  20,EE
0BAC:  MOVLW  01
0BAE:  MOVWF  xF0
0BB0:  RCALL  09EE
0BB2:  MOVLB  4
....................             }  
....................          }  
....................       }  
....................  
....................       else if (USTAT==USTAT_IN_E0) {   //pic -> host transfer completed  
0BB4:  BRA    0BF6
0BB6:  MOVLB  0
0BB8:  MOVF   F6C,W
0BBA:  SUBLW  04
0BBC:  BNZ   0BE2
....................          __setup_0_tx_size=0xFF;  
0BBE:  MOVLW  FF
0BC0:  MOVWF  20
....................          usb_isr_tok_in_dne(0);  
0BC2:  CLRF   xED
0BC4:  RCALL  0B1A
....................          if (__setup_0_tx_size!=0xFF)  
0BC6:  INCFSZ 20,W
0BC8:  BRA    0BCC
0BCA:  BRA    0BDC
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_TOGGLE);  
0BCC:  CLRF   xED
0BCE:  CLRF   xEF
0BD0:  MOVFF  20,EE
0BD4:  MOVLW  02
0BD6:  MOVWF  xF0
0BD8:  RCALL  09EE
....................          else  
0BDA:  BRA    0BE0
....................             usb_init_ep0_setup();  
0BDC:  CALL   025A
....................       }  
....................  
....................       else {  
0BE0:  BRA    0BF4
....................          if (!bit_test(USTAT,2)) {  
0BE2:  BTFSC  F6C.2
0BE4:  BRA    0BEE
....................             usb_isr_tok_out_dne(en);  
0BE6:  MOVFF  EC,ED
0BEA:  RCALL  0ACC
....................          }  
....................          else {  
0BEC:  BRA    0BF4
....................             usb_isr_tok_in_dne(en);  
0BEE:  MOVFF  EC,ED
0BF2:  RCALL  0B1A
0BF4:  MOVLB  4
....................          }  
....................       }  
.................... }  
0BF6:  MOVLB  0
0BF8:  GOTO   0C5E (RETURN)
....................  
.................... /**************************************************************  
.................... /* usb_request_send_response(len)  
.................... /* usb_request_get_data()  
.................... /* usb_request_stall()  
.................... /*  
.................... /* Input: len - size of packet to send  
.................... /*  
.................... /* Summary: After we process a SETUP request, we have 1 of three responses:  
.................... /*            1.) send a response IN packet  
.................... /*            2.) wait for followup OUT packet(s) with data  
.................... /*            3.) stall because we don't support that SETUP request  
.................... /*  
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold  
.................... /*          the response and the USB Request handler code will call  
.................... /*          usb_request_send_response() to let us know how big the packet is.  
.................... /*  
.................... /*          If we are waiting for more data, usb_request_get_data() will  
.................... /*          be called by the USB request handler code to configure the EP0 OUT  
.................... /*          endpoint to be ready for more data  
.................... /*  
.................... /*          If we don't support a request, usb_request_stall() will be called  
.................... /*          by the USB request handler code to stall the endpoint 0.  
.................... /*  
.................... /***************************************************************/  
.................... void usb_request_send_response(int len) {  
....................    __setup_0_tx_size=len;  
*
02C0:  MOVFF  F0,20
.................... }  
02C4:  RETLW  00
....................  
.................... void usb_request_get_data(void) {  
....................    __setup_0_tx_size=0xFE;  
.................... }  
....................  
.................... void usb_request_stall(void) {  
....................    __setup_0_tx_size=0xFF;  
02C6:  MOVLW  FF
02C8:  MOVWF  20
.................... }  
02CA:  RETLW  00
....................  
.................... /// END USB Interrupt Service Routine  
....................  
.................... #ENDIF 
....................  
.................... #include <USBdescHIDTest.h>     // USB Configuration and Device descriptors 
.................... //------------------------------------------------------------------------------ 
.................... // USBdescHIDTest.h                            
.................... // An example set of device & configuration descriptors.  
.................... //------------------------------------------------------------------------------ 
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... ////                   **** DEFINITIONS *****                          //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (FALSE) - Set to TRUE if your device supports        //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            Only the 18Fxx5x USB peripheral can    //// 
.................... ////                            have a value larger than 8.            //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE  //set to false to opt for less RAM, true to opt for less ROM 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     0 
.................... #define USB_ENABLE_BULK         0x01 
.................... #define USB_ENABLE_ISOCHRONOUS  0x02 
.................... #define USB_ENABLE_INTERRUPT    0x03 
.................... #define USB_ENABLE_CONTROL      0x04 
....................  
.................... //// DO NOT CHANGE THE FOLLOWING VALUES: 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #else 
.................... struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #endif 
....................  
.................... int16 __usb_kbhit_status; 
....................  
.................... /// *** User function prototypes 
.................... void usb_wait_for_enumeration(void); 
.................... int1 usb_unermated(void); 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout); 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout); 
....................  
.................... /// *** Token and request hanlder function prototypes 
.................... void usb_token_reset(); 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_request_send_response(int len);   //always sends usb_ep0_rx_buffer[] to endpoint 0 with a toggle of DATA 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tok_in_dne(int8 endpoint); 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
....................  
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
....................  
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
....................  
.................... void usb_finish_set_address(void); 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // HID Report.  Tells HID driver how to handle and deal with received data.   
.................... // HID Reports can be extremely complex, see HID specifcation for help on  
.................... // writing your own. 
.................... // 
.................... //  CCS example uses a vendor specified usage, that sends and 
.................... //  receives 2 absolute bytes ranging from 0 to 0xFF. 
.................... //------------------------------------------------------------------------------ 
.................... const char USB_CLASS_SPECIFIC_DESC[] = { 
....................       0x06, 0xFF, 0xA0,         // Usage Page = Vendor Defined 
....................       0x09, 0x01,               // Usage = Vendor Defined 
....................       0xA1, 0x01,               // Collection = Application 
....................        
....................       0x09, 0x03,               // Usage = Vendor Defined 
....................       0x15, 0x00,               // Logical minimum (0) 
....................       0x25, 0x00FF,             // Logical maximum (255), Unsigned 
....................       0x75, 0x08,               // Item size = 8(bits), each item is 1 byte 
....................       0x95, USB_REPORT_SIZE_RX, // Report count = number of items (bytes) 
....................       0x81, 0x02,               // Input (Data, Var, Abs) 
....................        
....................       0x09, 0x04,               // Usage = Vendor Defined 
....................       0x15, 0x00,               // Logical minimum (0) 
....................       0x25, 0x00FF,             // Logical maximum (255), Unsigned 
....................       0x75, 0x08,               // Report size = 8 (bits) 
....................       0x95, USB_REPORT_SIZE_TX, // Report count = number of items (bytes) 
....................       0x91, 0x02,               // Output (Data, Var, Abs 
....................        
....................       0xC0                      // End Collection 
.................... }; 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // If a class has an extra descriptor not part of the config descriptor, this  
.................... // lookup table defines where to look for it in the const USB_CLASS_SPECIFIC_DESC[] array. 
.................... //------------------------------------------------------------------------------ 
.................... const int16 USB_CLASS_SPECIFIC_DESC_LOOKUP[USB_NUM_CONFIGURATIONS][1] = {0}; 
.................... //------------------------------------------------------------------------------ 
.................... // If a class has an extra descriptor not part of the config descriptor, this  
.................... // lookup table defines the size of that descriptor.  
.................... //------------------------------------------------------------------------------ 
.................... const int16 USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[USB_NUM_CONFIGURATIONS][1] =  { 
....................     32  // config 1 - interface 0 
.................... }; 
.................... //------------------------------------------------------------------------------ 
.................... // start config descriptor, right now we only support one configuration descriptor. 
.................... // the config, interface, class, and endpoint goes into this array. 
.................... //------------------------------------------------------------------------------ 
.................... #DEFINE USB_TOTAL_CONFIG_LEN      41  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
.................... const char USB_CONFIG_DESC[] = { 
....................    // IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................    //    config(s) 
....................    //    interface(s) 
....................    //    class(es) 
....................    //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN,    //length of descriptor size          ==1 
....................          USB_DESC_CONFIG_TYPE,   //constant CONFIGURATION (CONFIGURATION 0x02)     ==2 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==3,4 
....................          1,                      //number of interfaces this device supports       ==5 
....................          0x01,                   //identifier for this configuration.  (IF we had more than one configurations)      ==6 
....................          0x00,                   //index of string descriptor for this configuration      ==7 
....................          0xC0,                   //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==8 
....................          0x32,                   //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA) 
....................  
....................    //interface descriptor 1 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =10 
....................          USB_DESC_INTERFACE_TYPE,//constant INTERFACE (INTERFACE 0x04)       =11 
....................          0x00,                   //number defining this interface (IF we had more than one interface)    ==12 
....................          0x00,                   //alternate setting     ==13 
....................          2,                      //number of endpoins, except 0 (pic167xx has 3, but we dont have to use all).       ==14 
....................          0x03,                   //class code, 03 = HID     ==15 
....................          0x00,                   //subclass code //boot     ==16 
....................          0x00,                   //protocol code      ==17 
....................          0x00,                   //index of string descriptor for interface      ==18 
....................  
....................    //class descriptor 1  (HID) 
....................          USB_DESC_CLASS_LEN,     //length of descriptor    ==19 
....................          USB_DESC_CLASS_TYPE,    //dscriptor type (0x21 == HID)      ==20 
....................          0x00,0x01,              //hid class release number (1.0) (try 1.10)      ==21,22 
....................          0x00,                   //localized country code (0 = none)       ==23 
....................          0x01,                   //number of hid class descrptors that follow (1)      ==24 
....................          0x22,                   //report descriptor type (0x22 == HID)                ==25 
....................          USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][0], 0x00, //length of report descriptor            ==26,27 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN,  //length of descriptor                   ==28 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==29 
....................          0x81,                   //endpoint number and direction (0x81 = EP1 IN)       ==30 
....................          0x03,                   //transfer type supported (0x03 is interrupt)         ==31 
....................          USB_EP1_TX_SIZE,0x00,   //maximum packet size supported                  ==32,33 
....................          10,                     //polling interval, in ms.  (cant be smaller than 10)      ==34 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN,  //length of descriptor                   ==35 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==36 
....................          0x01,                   //endpoint number and direction (0x01 = EP1 OUT)      ==37 
....................          0x03,                   //transfer type supported (0x03 is interrupt)         ==38 
....................          USB_EP1_RX_SIZE,0x00,   //maximum packet size supported                  ==39,40 
....................          10                      //polling interval, in ms.  (cant be smaller than 10)    ==41 
.................... }; 
.................... //------------------------------------------------------------------------------ 
.................... //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
.................... //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
.................... //  a specific descriptor in the above table. 
.................... //NOTE: DO TO A LIMITATION OF THE CCS CODE, ALL HID INTERFACES MUST START AT 0 AND BE SEQUENTIAL 
.................... //      FOR EXAMPLE, IF YOU HAVE 2 HID INTERFACES THEY MUST BE INTERFACE 0 AND INTERFACE 1 
.................... //------------------------------------------------------------------------------ 
.................... #define USB_NUM_HID_INTERFACES   1 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //the maximum number of interfaces seen on any config for example, if config 1  
.................... // has 1 interface and config 2 has 2 interfaces you must define this as 2 
.................... //------------------------------------------------------------------------------ 
.................... #define USB_MAX_NUM_INTERFACES   1 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //define how many interfaces there are per config.  [0] is the first config, etc. 
.................... //------------------------------------------------------------------------------ 
.................... const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={1}; 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // define where to find class descriptors first dimension is the config number 
.................... // second dimension specifies which interface last dimension specifies which class  
.................... // in this interface to get, but most will only have 1 class per interface 
.................... // if a class descriptor is not valid, set the value to 0xFFFF 
.................... //------------------------------------------------------------------------------ 
.................... const int16 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][1][1]=  { 
....................    18  //config 1 - interface 0 - class 1 
.................... }; 
.................... #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................    #error USB_TOTAL_CONFIG_LEN not defined correctly 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
.................... //   start device descriptors 
.................... //------------------------------------------------------------------------------ 
.................... const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={  
....................        //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN,       //the length of this report   ==1 
....................          0x01,                      //the constant DEVICE (DEVICE 0x01)  ==2 
....................          0x10,0x01,                 //usb version in bcd (pic167xx is 1.1) ==3,4 
....................          0x00,                      //class code ==5 
....................          0x00,                      //subclass code ==6 
....................          0x00,                      //protocol code ==7 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==8 
....................          0x61,0x04,                 //vendor id (0x04D8 is Microchip, or is it 0x0461 ??) 
....................          0x21,0x00,                 //product id   ==11,12  //don't use ffff says usb-by-example guy.  oops 
....................          0x00,0x01,                 //device release number  ==13,14 
....................          0x01,                      //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==15 
....................          0x02,                      //index of string descriptor of the product  ==16 
....................          0x00,                      //index of string descriptor of serial number  ==17 
....................          USB_NUM_CONFIGURATIONS     //number of possible configurations  ==18 
.................... }; 
.................... //------------------------------------------------------------------------------ 
.................... // start string descriptors 
.................... // String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... // 
.................... // You must define the length else get_next_string_character() will not see the string 
.................... // Current code only supports 10 strings (0 thru 9) 
.................... // the offset of the starting location of each string.   
.................... // offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... //------------------------------------------------------------------------------ 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'D',0, 
....................          'L',0, 
....................          'P',0, 
....................    //string 2 
....................          26, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'D',0, 
....................          'O',0, 
....................          'S',0, 
....................          'e',0, 
....................          'y',0, 
....................          '-',0, 
....................          '2',0, 
....................          '0',0, 
....................          '0',0, 
....................          '0',0, 
....................          '.',0, 
....................          '.',0 
.................... }; 
.................... //------------------------------------------------------------------------------ 
.................... #ENDIF 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... #include <usb.c>                // handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... //// Many settings important to the USB API are defined in usb.h.      //// 
.................... //// See the documentation in usb.h about these settings.              //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The following functions are of use to  //// 
.................... //// the user (for more docs on the functions, read the comments at    //// 
.................... //// each function):                                                   //// 
.................... ////                                                                   //// 
.................... ////    **********************  FUNCTIONS  ***********************     //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral until you //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit() - Returns true if OUT endpoint contains data from     //// 
.................... ////               host.                                               //// 
.................... ////                                                                   //// 
.................... //// usb_puts() - Sends a multiple packet message to the host          //// 
.................... ////                                                                   //// 
.................... //// usb_gets() - Gets multiple packets from the host                  //// 
.................... ////                                                                   //// 
.................... //// The rest of the functions in this file are part of the USB        //// 
.................... //// interrupt service routine and are not meant to be called by the   //// 
.................... //// user.                                                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must include the following functions:                             //// 
.................... ////                                                                   //// 
.................... //// void usb_stall_ep(int8 endpoint);                                 //// 
.................... //// void usb_unstall_ep(int8 endpoint);                               //// 
.................... //// int1 usb_endpoint_stalled(int8 endpoint);                         //// 
.................... //// void usb_set_address(int8 address);                               //// 
.................... //// void usb_set_configured(int config);                              //// 
.................... //// int8 usb_get_packet(int8 endpoint, int8 * ptr, int8 max);         //// 
.................... //// int1 usb_put_packet(int endpoint, int * ptr, int len, USB_DTS_BIT toggle); //// 
.................... //// void usb_request_send_response(int8 len);                                //// 
.................... //// int1 usb_kbhit(int8 endpoint);                                    //// 
.................... ////                                                                   //// 
.................... //// CCS provides a USB peripheral hardware layer for PIC16C7x5        //// 
.................... //// (pic_usb.h), 18Fxx5x (pic18_usb.h) and National's USBN960x        //// 
.................... //// (usbn960x.c).  See these files for more documentation.            //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code, which includes:   //// 
.................... ////   usb_desc_*.h - an example set of config and device descriptor   //// 
.................... ////   usb.c - USB token and request handler code                      //// 
.................... ////   usb.h - definitions, prototypes and global variables            //// 
.................... ////                                                                   //// 
.................... //// The following examples are provided by CCS:                       //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////                                                                   //// 
.................... ////                   **** DEFINITIONS *****                          //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (FALSE) - Set to TRUE if your device supports        //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            Only the 18Fxx5x USB peripheral can    //// 
.................... ////                            have a value larger than 8.            //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE  //set to false to opt for less RAM, true to opt for less ROM 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     0 
.................... #define USB_ENABLE_BULK         0x01 
.................... #define USB_ENABLE_ISOCHRONOUS  0x02 
.................... #define USB_ENABLE_INTERRUPT    0x03 
.................... #define USB_ENABLE_CONTROL      0x04 
....................  
.................... //// DO NOT CHANGE THE FOLLOWING VALUES: 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #else 
.................... struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } USB_stack_status; 
.................... #endif 
....................  
.................... int16 __usb_kbhit_status; 
....................  
.................... /// *** User function prototypes 
.................... void usb_wait_for_enumeration(void); 
.................... int1 usb_unermated(void); 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout); 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout); 
....................  
.................... /// *** Token and request hanlder function prototypes 
.................... void usb_token_reset(); 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_request_send_response(int len);   //always sends usb_ep0_rx_buffer[] to endpoint 0 with a toggle of DATA 
....................  
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tok_in_dne(int8 endpoint); 
.................... void usb_isr_tok_out_dne(int8 endpoint); 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
....................  
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
....................  
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
....................  
.................... void usb_finish_set_address(void); 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... int8 usb_getdesc_ptr; int8 usb_getdesc_len=0;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #define usb_kbhit(x) bit_test(__usb_kbhit_status,x) 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: Use this to see if device is configured / enumerated. 
.................... /***************************************************************/ 
.................... #define usb_enumerated() (USB_stack_status.curr_config) 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void) { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts(endpoint, *ptr, len, timeout) 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before timeout. 
.................... /*                   set to 0 for no timeout. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  If sending 
.................... /*          only one packet it is more effecient to use only usb_put_packet() 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(int8 endpoint, int8 * ptr, int16 len, int8 timeout) { 
....................    int16 i=0; 
....................    int1 res; 
....................    int16 this_packet_len; 
....................    int16 packet_size; 
....................    int32 timeout_1us; 
....................  
....................    packet_size=usb_ep_tx_size[endpoint]; 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len=packet_size;} 
....................       else {this_packet_len=len-i;} 
....................       do { 
....................          res=usb_put_packet(endpoint,ptr + i,this_packet_len,USB_DTS_TOGGLE);   //send 64 byte packets 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................       i+=packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res=usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && timeout_1us); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before timeout. 
.................... /*                   set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /* NOTE: NOT THOUROUGHLY TESTED.  I AM NOT EVEN SURE IF THIS IS A GOOD IDEA 
.................... /* 
.................... /*****************************************************************************/ 
.................... int8 usb_gets(int8 endpoint, int8 * ptr, int16 max, int16 timeout) { 
....................    int16 ret=0; 
....................    int16 to; 
....................    int16 len; 
....................    int16 packet_size; 
....................    int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (to!=timeout) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output: modifies global variables USB_Interface[], in[], usb_getdesc_ptr, 
.................... /*         usb_getdesc_len, USB_status_device, USB_dev_req 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset() { 
....................    int i; 
....................  
....................  
....................  
....................       for (i=0;i<USB_MAX_NUM_INTERFACES;i++) { 
*
020A:  CLRF   xEC
020C:  MOVF   xEC,F
020E:  BNZ   0224
....................          USB_Interface[i]=0;   //reset each interface to default 
0210:  CLRF   03
0212:  MOVF   xEC,W
0214:  ADDLW  27
0216:  MOVWF  FE9
0218:  MOVLW  00
021A:  ADDWFC 03,W
021C:  MOVWF  FEA
021E:  CLRF   FEF
....................       } 
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) { 
....................        hid_protocol[i]=1; 
....................    } 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
0220:  INCF   xEC,F
0222:  BRA    020C
....................    usb_cdc_init(); 
....................   #endif 
....................  
....................     USB_stack_status.curr_config=0;      //unconfigured device 
0224:  CLRF   1A
....................  
....................     USB_stack_status.status_device=1;    //previous state.  init at none 
0226:  MOVLW  01
0228:  MOVWF  1B
....................     USB_stack_status.dev_req=NONE;       //previous token request state.  init at none 
022A:  CLRF   19
.................... } 
022C:  RETLW  00
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... // 
.................... int1 usb_endpoint_is_valid(int8 endpoint) { 
....................    int1 direction; 
....................    direction = bit_test(endpoint,7); 
*
0746:  BCF    xEE.0
0748:  BTFSC  xED.7
074A:  BSF    xEE.0
....................    endpoint &= 0x7F; 
074C:  BCF    xED.7
....................    if (direction) { //IN 
074E:  BTFSS  xEE.0
0750:  BRA    0772
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
0752:  CLRF   03
0754:  MOVF   xED,W
0756:  MOVFF  FF2,EF
075A:  BCF    FF2.7
075C:  RCALL  009E
075E:  BTFSC  xEF.7
0760:  BSF    FF2.7
0762:  XORLW  00
0764:  BNZ   076A
0766:  MOVLW  00
0768:  BRA    076C
076A:  MOVLW  01
076C:  MOVWF  01
076E:  BRA    0790
....................    } 
....................    else {   //OUT 
0770:  BRA    0790
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
0772:  CLRF   03
0774:  MOVF   xED,W
0776:  MOVFF  FF2,EF
077A:  BCF    FF2.7
077C:  RCALL  009E
077E:  BTFSC  xEF.7
0780:  BSF    FF2.7
0782:  XORLW  00
0784:  BNZ   078A
0786:  MOVLW  00
0788:  BRA    078C
078A:  MOVLW  01
078C:  MOVWF  01
078E:  BRA    0790
....................    } 
.................... } 
0790:  GOTO   0874 (RETURN)
....................  
.................... ///---------------------------------------------------------------/// 
.................... /// Processing Message stages is the biggest portion of the ISR   /// 
.................... ///---------------------------------------------------------------/// 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token.  Should be 0. 
.................... /* 
.................... /* Summary: When receiving an IN token from the PC on endpoint 0 that means the 
.................... /*          host is asking for a response from a setup token, or the next packet 
.................... /*          from a currently processing token.  (For example, a 24 byte descriptor 
.................... /*          would require 3 IN tokens if the packet size is 8 bytes.)  USB_dev_req 
.................... /*          is a global variable that defines what setup token we are currently processing. 
.................... /* 
.................... /* Part of USB interrupt service routine. 
.................... /* Only checks endpoint 0. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(int8 endpoint) { 
....................    if (endpoint==0) { 
*
0B1A:  MOVF   xED,F
0B1C:  BNZ   0B30
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
0B1E:  DECFSZ 19,W
0B20:  BRA    0B28
0B22:  CALL   02CC
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
0B26:  BRA    0B30
0B28:  MOVF   19,W
0B2A:  SUBLW  02
0B2C:  BNZ   0B30
0B2E:  BRA    0B0C
....................    } 
....................   #if USB_CDC_DEVICE 
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
....................       usb_isr_tok_in_cdc_data_dne(); 
....................   } 
....................   #endif 
.................... } 
0B30:  RETLW  00
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data. 
.................... /*        This code doesn't allow reception of data from EP0. (Add later) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy incoming 
.................... /*          to the pic), but not out setup tokens.  Data is placed into a 
.................... /*          a buffer if it is empty, and the rx flag is set.  If the buffer 
.................... /*          is not empty then the overrun bit of that EP status byte is set it. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(int8 endpoint) { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
0ACC:  MOVF   xED,F
0ACE:  BNZ   0AD6
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
....................      #else 
....................       usb_init_ep0_setup(); 
0AD0:  CALL   025A
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
....................       usb_isr_tok_out_cdc_data_dne(); 
....................    } 
....................   #endif 
....................    else { 
0AD4:  BRA    0AF4
....................       bit_set(__usb_kbhit_status,endpoint); 
0AD6:  CLRF   03
0AD8:  MOVLW  01
0ADA:  MOVWF  02
0ADC:  MOVF   xED,W
0ADE:  MOVWF  00
0AE0:  BZ    0AEC
0AE2:  BCF    FD8.0
0AE4:  RLCF   02,F
0AE6:  RLCF   03,F
0AE8:  DECFSZ 00,F
0AEA:  BRA    0AE2
0AEC:  MOVF   02,W
0AEE:  IORWF  1D,F
0AF0:  MOVF   03,W
0AF2:  IORWF  1E,F
....................    } 
.................... } 
0AF4:  RETLW  00
....................  
....................  
.................... //---- process setup message stage -----------// 
.................... ////// HUGE - most of our code is to read setup messages //// 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the 8 bytes of the setup packet. 
.................... /* 
.................... /* Output: The DTS we expect for the next packet on OUT 0. 
.................... /* 
.................... /* Summary: This function is the start of code that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration, Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[8] now contains setup data packet, which has the following records 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
....................                                        (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet 
.................... /*                        for host-to-device, this exactly how many bytes in data packet 
.................... /*                        for device-to-host, this is the maximum bytes that can fit one packet 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void) { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
08DE:  CLRF   19
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
08E0:  MOVLB  5
08E2:  MOVF   x00,W
08E4:  ANDLW  7F
08E6:  MOVLB  0
08E8:  BZ    08F8
08EA:  XORLW  01
08EC:  BZ    08FA
08EE:  XORLW  03
08F0:  BZ    08FC
08F2:  XORLW  23
08F4:  BZ    08FE
08F6:  BRA    0900
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
08F8:  BRA    0604
....................          break; 
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
08FA:  BRA    06A8
....................          break; 
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
08FC:  BRA    086E
....................          break; 
....................  
.................... #IF USB_HID_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc," hid"); 
....................          usb_isr_tkn_setup_ClassInterface(); 
08FE:  BRA    08CE
....................          break; 
.................... #endif 
....................  
.................... #if USB_CDC_DEVICE 
....................       case 0x21: 
....................          debug_usb(debug_putc," cdc"); 
....................          usb_isr_tkn_cdc(); 
....................          break; 
.................... #endif 
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
0900:  RCALL  02C6
....................          break; 
0902:  BRA    0904
....................    } 
.................... } 
0904:  GOTO   0B52 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
0604:  MOVLB  5
0606:  MOVF   x01,W
0608:  MOVLB  0
060A:  BZ    0626
060C:  XORLW  01
060E:  BZ    0638
0610:  XORLW  02
0612:  BZ    0650
0614:  XORLW  06
0616:  BZ    0666
0618:  XORLW  03
061A:  BZ    0674
061C:  XORLW  0E
061E:  BZ    0678
0620:  XORLW  01
0622:  BZ    0684
0624:  BRA    06A0
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
0626:  MOVFF  1B,540
....................             usb_ep0_tx_buffer[1]=0; 
062A:  MOVLB  5
062C:  CLRF   x41
....................             usb_request_send_response(2); 
062E:  MOVLW  02
0630:  MOVLB  0
0632:  MOVWF  xF0
0634:  RCALL  02C0
....................             break; 
0636:  BRA    06A4
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
0638:  MOVLB  5
063A:  DECFSZ x02,W
063C:  BRA    064A
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
063E:  MOVLW  01
0640:  ANDWF  1B,F
....................                usb_put_0len_0(); 
0642:  MOVLB  0
0644:  CLRF   xF0
0646:  RCALL  02C0
....................             } 
....................             else 
0648:  BRA    064E
....................                usb_request_stall(); 
064A:  MOVLB  0
064C:  RCALL  02C6
....................             break; 
064E:  BRA    06A4
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
0650:  MOVLB  5
0652:  DECFSZ x02,W
0654:  BRA    0660
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
0656:  BSF    1B.1
....................                usb_put_0len_0(); 
0658:  MOVLB  0
065A:  CLRF   xF0
065C:  RCALL  02C0
....................             } 
....................             else 
065E:  BRA    0664
....................                usb_request_stall(); 
0660:  MOVLB  0
0662:  RCALL  02C6
....................             break; 
0664:  BRA    06A4
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
0666:  MOVLW  02
0668:  MOVWF  19
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
066A:  MOVFF  502,24
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................          	USB_stack_status.curr_config=0;	// make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
066E:  CLRF   xF0
0670:  RCALL  02C0
....................             break; 
0672:  BRA    06A4
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
0674:  RCALL  0384
....................             break; 
0676:  BRA    06A4
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
0678:  MOVFF  1A,540
....................             usb_request_send_response(1); 
067C:  MOVLW  01
067E:  MOVWF  xF0
0680:  RCALL  02C0
....................             break; 
0682:  BRA    06A4
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
0684:  MOVLB  5
0686:  MOVF   x02,W
0688:  SUBLW  01
068A:  BNC   069C
....................                debug_usb(debug_putc,"SC"); 
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
068C:  MOVFF  502,1A
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
0690:  MOVFF  502,ED
0694:  MOVLB  0
0696:  BRA    0472
....................                usb_put_0len_0(); 
0698:  CLRF   xF0
069A:  RCALL  02C0
....................             } 
....................             break; 
069C:  MOVLB  0
069E:  BRA    06A4
....................  
....................       default: 
....................             usb_request_stall(); 
06A0:  RCALL  02C6
....................             break; 
06A2:  BRA    06A4
....................    } 
.................... } 
06A4:  GOTO   0904 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
06A8:  MOVFF  1A,ED
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
06AC:  MOVLB  5
06AE:  MOVF   x01,W
06B0:  MOVLB  0
06B2:  BZ    06C2
06B4:  XORLW  0A
06B6:  BZ    06D2
06B8:  XORLW  01
06BA:  BZ    0716
06BC:  XORLW  0D
06BE:  BZ    073A
06C0:  BRA    073E
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
06C2:  MOVLB  5
06C4:  CLRF   x40
....................             usb_ep0_tx_buffer[1]=0; 
06C6:  CLRF   x41
....................             usb_request_send_response(2); 
06C8:  MOVLW  02
06CA:  MOVLB  0
06CC:  MOVWF  xF0
06CE:  RCALL  02C0
....................             break; 
06D0:  BRA    0742
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
06D2:  MOVF   xED,F
06D4:  BZ    0712
06D6:  MOVLW  01
06D8:  SUBWF  xED,W
06DA:  CLRF   03
06DC:  MOVFF  FF2,EF
06E0:  BCF    FF2.7
06E2:  RCALL  018E
06E4:  BTFSC  xEF.7
06E6:  BSF    FF2.7
06E8:  MOVWF  01
06EA:  MOVLB  5
06EC:  SUBWF  x04,W
06EE:  BTFSS  FD8.0
06F0:  BRA    06F6
06F2:  MOVLB  0
06F4:  BRA    0712
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
06F6:  CLRF   03
06F8:  MOVF   x04,W
06FA:  ADDLW  27
06FC:  MOVWF  FE9
06FE:  MOVLW  00
0700:  ADDWFC 03,W
0702:  MOVWF  FEA
0704:  MOVFF  FEF,540
....................                usb_request_send_response(1);; //send byte back 
0708:  MOVLW  01
070A:  MOVLB  0
070C:  MOVWF  xF0
070E:  RCALL  02C0
....................             } 
....................             else 
0710:  BRA    0714
....................                usb_request_stall(); 
0712:  RCALL  02C6
....................             break; 
0714:  BRA    0742
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
0716:  MOVF   xED,F
0718:  BZ    0736
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
071A:  CLRF   03
071C:  MOVLB  5
071E:  MOVF   x04,W
0720:  ADDLW  27
0722:  MOVWF  FE9
0724:  MOVLW  00
0726:  ADDWFC 03,W
0728:  MOVWF  FEA
072A:  MOVFF  502,FEF
....................                usb_put_0len_0(); 
072E:  MOVLB  0
0730:  CLRF   xF0
0732:  RCALL  02C0
....................             } 
....................             else 
0734:  BRA    0738
....................                usb_request_stall(); 
0736:  RCALL  02C6
....................             break; 
0738:  BRA    0742
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
073A:  RCALL  0384
....................             break; 
073C:  BRA    0742
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
073E:  RCALL  02C6
....................             break; 
0740:  BRA    0742
....................    } 
.................... } 
0742:  GOTO   0904 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
086E:  MOVFF  504,ED
0872:  BRA    0746
0874:  MOVF   01,F
0876:  BZ    08CA
....................       switch(usb_ep0_rx_buffer[1]) { 
0878:  MOVLB  5
087A:  MOVF   x01,W
087C:  XORLW  01
087E:  MOVLB  0
0880:  BZ    088C
0882:  XORLW  02
0884:  BZ    0898
0886:  XORLW  03
0888:  BZ    08A4
088A:  BRA    08C6
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
088C:  MOVFF  504,ED
0890:  BRA    0794
....................                usb_put_0len_0(); 
0892:  CLRF   xF0
0894:  RCALL  02C0
....................                break; 
0896:  BRA    08CA
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
0898:  MOVFF  504,ED
089C:  BRA    07D6
....................                      usb_put_0len_0(); 
089E:  CLRF   xF0
08A0:  RCALL  02C0
....................                      break; 
08A2:  BRA    08CA
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
08A4:  MOVLB  5
08A6:  CLRF   x40
....................                usb_ep0_tx_buffer[1]=0; 
08A8:  CLRF   x41
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
08AA:  MOVFF  504,ED
08AE:  MOVLB  0
08B0:  BRA    081A
08B2:  MOVF   01,F
08B4:  BZ    08BE
....................                   usb_ep0_tx_buffer[0]=1; 
08B6:  MOVLW  01
08B8:  MOVLB  5
08BA:  MOVWF  x40
08BC:  MOVLB  0
....................                } 
....................                usb_request_send_response(2); 
08BE:  MOVLW  02
08C0:  MOVWF  xF0
08C2:  RCALL  02C0
....................                break; 
08C4:  BRA    08CA
....................  
....................          default: 
....................             usb_request_stall(); 
08C6:  RCALL  02C6
....................             break; 
08C8:  BRA    08CA
....................       } 
....................    } 
.................... } 
08CA:  GOTO   0904 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
08CE:  MOVLB  5
08D0:  MOVF   x01,W
08D2:  BRA    08D4
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
08D4:  MOVLB  0
08D6:  RCALL  02C6
....................             break; 
08D8:  BRA    08DA
....................    } 
.................... } 
08DA:  GOTO   0904 (RETURN)
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
0384:  CLRF   25
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
0386:  CLRF   1C
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
0388:  MOVLB  5
038A:  MOVF   x03,W
038C:  XORLW  01
038E:  MOVLB  0
0390:  BZ    03A4
0392:  XORLW  03
0394:  BZ    03AE
0396:  XORLW  01
0398:  BZ    03B4
039A:  XORLW  22
039C:  BZ    03E2
039E:  XORLW  03
03A0:  BZ    0406
03A2:  BRA    0454
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
03A4:  MOVLW  12
03A6:  MOVWF  26
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
03A8:  MOVLW  03
03AA:  MOVWF  1C
....................             break; 
03AC:  BRA    0458
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
03AE:  MOVLW  29
03B0:  MOVWF  26
....................             break; 
03B2:  BRA    0458
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
03B4:  MOVLW  02
03B6:  MOVWF  1C
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
03B8:  CLRF   03
03BA:  MOVLB  5
03BC:  MOVF   x02,W
03BE:  ADDLW  21
03C0:  MOVWF  FE9
03C2:  MOVLW  00
03C4:  ADDWFC 03,W
03C6:  MOVWF  FEA
03C8:  MOVFF  FEF,25
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
03CC:  CLRF   03
03CE:  MOVF   25,W
03D0:  MOVFF  FF2,EE
03D4:  BCF    FF2.7
03D6:  MOVLB  0
03D8:  RCALL  01C2
03DA:  BTFSC  xEE.7
03DC:  BSF    FF2.7
03DE:  MOVWF  26
....................             break; 
03E0:  BRA    0458
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][0]; 
03E2:  MOVLW  12
03E4:  MOVWF  25
....................             if (usb_getdesc_ptr!=0xFF) { 
03E6:  INCFSZ 25,W
03E8:  BRA    03EC
03EA:  BRA    0402
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
03EC:  CLRF   03
03EE:  MOVF   25,W
03F0:  MOVFF  FF2,EE
03F4:  BCF    FF2.7
03F6:  RCALL  0154
03F8:  BTFSC  xEE.7
03FA:  BSF    FF2.7
03FC:  MOVWF  26
....................                break; 
03FE:  BRA    0458
....................             } 
....................             else { 
0400:  BRA    0406
....................                usb_request_stall(); 
0402:  RCALL  02C6
....................                return; 
0404:  BRA    0470
....................             } 
....................  
....................  
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
0406:  BCF    FD8.0
0408:  MOVLB  5
040A:  RLCF   x04,W
040C:  CLRF   03
040E:  MOVFF  FF2,EE
0412:  BCF    FF2.7
0414:  MOVLB  0
0416:  RCALL  0130
0418:  TBLRD*+
041A:  MOVFF  FF5,03
041E:  BTFSC  xEE.7
0420:  BSF    FF2.7
0422:  MOVWF  25
....................             if (usb_getdesc_ptr !=0xFF) { 
0424:  INCFSZ 25,W
0426:  BRA    042A
0428:  BRA    0450
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
042A:  MOVLW  01
042C:  MOVWF  1C
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
042E:  BCF    FD8.0
0430:  MOVLB  5
0432:  RLCF   x04,W
0434:  CLRF   03
0436:  MOVFF  FF2,EE
043A:  BCF    FF2.7
043C:  MOVLB  0
043E:  RCALL  0142
0440:  TBLRD*+
0442:  MOVFF  FF5,03
0446:  BTFSC  xEE.7
0448:  BSF    FF2.7
044A:  MOVWF  26
....................                break; 
044C:  BRA    0458
....................             } 
....................             else { 
044E:  BRA    0454
....................                usb_request_stall(); 
0450:  RCALL  02C6
....................                return; 
0452:  BRA    0470
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
0454:  RCALL  02C6
....................             return; 
0456:  BRA    0470
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
0458:  MOVLB  5
045A:  MOVF   x07,F
045C:  BNZ   0468
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
045E:  MOVF   26,W
0460:  SUBWF  x06,W
0462:  BC    0468
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
0464:  MOVFF  506,26
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
0468:  MOVLW  01
046A:  MOVWF  19
....................    usb_copy_desc_seg_to_ep(); 
046C:  MOVLB  0
046E:  RCALL  02CC
.................... } 
0470:  RETLW  00
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
.................... 	USB_stack_status.curr_config=0;	// make sure current configuration is 0 
*
0B0C:  CLRF   1A
....................  
....................    #ifdef __PIC__ 
.................... 	USB_stack_status.dev_req=NONE;  // no request pending 
0B0E:  CLRF   19
....................    usb_set_address(USB_address_pending); 
0B10:  MOVFF  24,EE
0B14:  BRA    0AF6
....................    #endif 
.................... } 
0B16:  GOTO   0B30 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
....................    int i=0; 
*
02CC:  CLRF   xEE
....................    char c; 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
....................    { 
02CE:  MOVF   26,F
02D0:  BZ    034E
02D2:  MOVF   xEE,W
02D4:  SUBLW  3F
02D6:  BNC   034E
....................       switch(USB_stack_status.getdesc_type) { 
02D8:  MOVF   1C,W
02DA:  ADDLW  FC
02DC:  BC    0334
02DE:  ADDLW  04
02E0:  GOTO   0362
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
02E4:  CLRF   03
02E6:  MOVF   25,W
02E8:  MOVFF  FF2,F0
02EC:  BCF    FF2.7
02EE:  RCALL  0154
02F0:  BTFSC  xF0.7
02F2:  BSF    FF2.7
02F4:  MOVWF  xEF
....................             break; 
02F6:  BRA    0334
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
02F8:  CLRF   03
02FA:  MOVF   25,W
02FC:  MOVFF  FF2,F0
0300:  BCF    FF2.7
0302:  RCALL  0100
0304:  BTFSC  xF0.7
0306:  BSF    FF2.7
0308:  MOVWF  xEF
....................             break; 
030A:  BRA    0334
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
030C:  CLRF   03
030E:  MOVF   25,W
0310:  MOVFF  FF2,F0
0314:  BCF    FF2.7
0316:  RCALL  01C2
0318:  BTFSC  xF0.7
031A:  BSF    FF2.7
031C:  MOVWF  xEF
....................             break; 
031E:  BRA    0334
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
0320:  CLRF   03
0322:  MOVF   25,W
0324:  MOVFF  FF2,F0
0328:  BCF    FF2.7
032A:  RCALL  01A0
032C:  BTFSC  xF0.7
032E:  BSF    FF2.7
0330:  MOVWF  xEF
....................             break; 
0332:  BRA    0334
....................       } 
....................       usb_getdesc_ptr++; 
0334:  INCF   25,F
....................       usb_getdesc_len--; 
0336:  DECF   26,F
....................       usb_ep0_tx_buffer[i++]=c; 
0338:  MOVF   xEE,W
033A:  INCF   xEE,F
033C:  CLRF   03
033E:  ADDLW  40
0340:  MOVWF  FE9
0342:  MOVLW  05
0344:  ADDWFC 03,W
0346:  MOVWF  FEA
0348:  MOVFF  EF,FEF
....................    } 
034C:  BRA    02CE
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
034E:  MOVF   26,F
0350:  BNZ   035A
0352:  MOVF   xEE,W
0354:  SUBLW  40
0356:  BZ    035A
....................          USB_stack_status.dev_req = NONE; 
0358:  CLRF   19
....................    } 
....................  
....................    usb_request_send_response(i); 
035A:  MOVFF  EE,F0
035E:  RCALL  02C0
.................... } 
0360:  RETLW  00
....................  
.................... #ENDIF 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(int *)==1 
.................... #define ptrdiff_t int 
.................... #else 
.................... #define ptrdiff_t long 
.................... #endif 
....................  
.................... #define size_t int 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* compiler ignored the name 'strcpy()'; perhaps, it's reserved? 
....................    Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1*/ 
....................  
.................... char *strcopy(char *s1, char *s2) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; *s2 != 0; s++, s2++) { 
....................      *s = *s2; 
....................   } 
....................   *s = *s2; 
....................   return(s1); 
.................... } 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   int n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,int c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, int c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... int *strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, int c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... int *strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(int errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... int *strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // Summary of pin definition (Pins may have multiple functions): 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... #define Spare_A0     PIN_A0          // Spare Pin 
.................... #define Spare_A1     PIN_A1          // Spare Pin 
.................... #define AUX2_Rx      PIN_A2          // AUX - RS232 port Receive 
.................... #define Spare_A2     PIN_A3          // Spare Pin 
.................... #define TestLED      PIN_A4          // Test LED (Active high) 
....................  
.................... #define MC_SSEL      PIN_A5          // SPI INput - FPGA to PIC Enable 
....................  
.................... #define FLASH_DI     PIN_B0          // PIC Out, Flash In  -> Pin5 
.................... #define FLASH_CLOCK  PIN_B1          // PIC Out, Flash Clk ->Pin6 
.................... #define FLASH_SELECT PIN_B2          // PIC Out, Flash /CS ->Pin1 
.................... #define FLASH_DO     PIN_C7          // PIC In,  Flash Out -> Pin2 
....................  
.................... #define Spare_B3     PIN_B3          // Spare Pin 
....................  
.................... #define FPGAReset    PIN_B4          // FPGA Reset 
.................... #define FPGALoad     PIN_B5          // FPGA Serial upload nConfig Line 
.................... #define FPGADOut     PIN_B6          // FPGA Serial upload data line 
.................... #define FPGAClock    PIN_B7          // FPGA Serial upload clock line 
....................  
.................... #define RTC_SCLK     PIN_C0          // RTC SCLK Line 
.................... #define RTC_SIO      PIN_C1          // RTC SIO Line 
.................... #define RTC_RST      PIN_C2          // RTC /RST Line 
....................  
.................... #define USBVCC       PIN_C3          // Reserved for USB VCC 
.................... #define USB_M        PIN_C4          // USB Negative 
.................... #define USB_P        PIN_C5          // USB Positive 
....................  
.................... #define AUX2_Tx      PIN_C6          // AUX - RS232 port Transmit 
....................  
.................... #define MC_MISO      PIN_C7          // SPI INput - FPGA to PIC  
.................... #define MC_MOSI      PIN_B0          // SPI INput - PIC to FPGA  
.................... #define MC_CLOCK     PIN_B1          // SPI INput - FPGA to PIC Clock 
.................... #define FLOPPY_SEL   PIN_B7          // PIC to FPGA Floppy select pin 
....................  
.................... //                      76543210     //  
.................... #define TRISA_Enabled 0b00101111     // All PIC SPI Enabled 
.................... #define TRISB_Master  0b00001000     // PIC is Master SPI to Flash 
.................... #define TRISB_Config  0b00001111     // PIC is set up to configure the FPGA 
.................... #define TRISB_Disable 0b00001111     // All PIC SPI Disabled  
.................... #define TRISC_Master  0b10001000     // PIC is Master SPI to Flash 
.................... #define TRISC_Slave   0b00001000     // PIC is Slave  SPI to FPGA 
.................... #define TRISC_Disable 0b10001000     // All PIC SPI Disabled 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // Global definitions 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... #define LED_ON      output_high     // LCD Enable  
.................... #define LED_OFF     output_low      // Turn LED Off 
.................... #define blksize     USB_REPORT_SIZE_RX      // Block size for Flash Functions 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // SPI Buffer window: 
.................... // This buffer contains information for the ZBC to read from as needed. The  
.................... // memory map for this window is as follows: 
.................... // 
.................... //    Address   Description 
.................... // -----------  ---------------------------------------------------------------- 
.................... // 0x00 - 0x07  Date and Time  
.................... //        0x08  Control, version 
.................... //        0x09  Floppy boot up control 
.................... // 0x0A - 0x0F  Reserved 
.................... // 0x10 - 0x1F  IO Window for transfer of data to and from PC to ZBC 
.................... //  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... short spi_enabled;          // Flag to indicate if PIC to ZBC SPI enabled 
.................... short spi_write;            // Flag to indicate next SPI byte is data 
.................... int   spi_buffer[32];       // 16 byte buffer for SPI message from FPGA 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // Include Drivers                                                            
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... #include "SPIFPGA.h"            // Include FPGA routines 
.................... //============================================================================== 
.................... //============================================================================== 
.................... // SPI  FPGA Controler Routines                                        SPIFPGA.H 
.................... // 
.................... // This driver controls the FPGA via an SPI interface. These are the low level 
.................... // driver routines to access the FPGA functions. 
.................... // 
.................... // DonnaWare International LLP Copyright (2001) All Rights Reserved         
.................... //============================================================================== 
.................... //============================================================================== 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // Library for FPGA SPI Interface                               
.................... // 
.................... // void FGPA_SPI_Init()  - Initializes the pins that control the device.    
.................... // int  SPI_xferByte()  - Writes and Reads a register from the device                      
.................... //                                                                
.................... //   Pin Assignments:                          
.................... //   SSEL    Device Select   
.................... //   MOSI    Device Data Oout    
.................... //   SCK     Device Clock               
.................... //   MISO    Device Data Input               
.................... // 
.................... //   #define DEVICE_SELECT       PIN_xx        // Device /CS 
.................... //   #define DEVICE_CLOCK        PIN_xx        // Device Clk 
.................... //   #define DEVICE_DO           PIN_xx        // Device to PIC 
.................... //   #define DEVICE_DI           PIN_xx        // PIC to Device 
.................... // 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... #define DEVICE_SELECT   MC_SSEL     // Device /CS 
.................... #define DEVICE_CLOCK    MC_CLOCK    // Device Clk 
.................... #define DEVICE_DI       MC_MISO     // PIC to Device 
.................... #define DEVICE_DO       MC_MOSI     // Device to PIC 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //     * * * USER CONFIGURATION Section, set these per Hardware set up * * * 
.................... //------------------------------------------------------------------------------ 
.................... #define UseHWSPI       1  // Set to 1 for HW, 0 for SW, must use correct pins for HW  
.................... #define MCU_SPI_MASTER 0  //  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // HW SPI SSP Routines                                                              
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... #if UseHWSPI 
....................     #byte SSPBUF  = 0x0FC9          // MSSP Receive Buffer/Transmit Register  
....................     #byte SSPCON  = 0x0FC6          // MSSP CONTROL REGISTER 1 (SPI MODE) 
....................     #byte SSPSTAT = 0x0FC7          // MSSP STATUS REGISTER (SPI MODE) 
....................     #bit  SSPBF   = SSPSTAT.0       // Status Bit, when set, data is ready  
....................     #bit  SSPSMP  = SSPSTAT.7       // SMP: Sample bit Must be 0 in slave mode 
....................     #bit  SSPWCOL = SSPCON.7        // Collision detect 
....................     #bit  SSPCKP  = SSPCON.4        // Clock Polarity Select bit, 1 = Idle state for clock is a high level 
....................  
....................     #define  READ_SSP()     (SSPBUF)  
....................     #define  SSP_HAS_DATA() (SSPBF)  
....................     #define  WAIT_FOR_SSP()  while(!SSP_HAS_DATA())  
....................     #define  WRITE_SSP(chr)  SSPBUF=(chr) 
....................  
....................     #if MCU_SPI_MASTER 
....................         int8 ssp_xfer(int8 data)  
....................         { 
....................             SSPWCOL = 0;                // Precautionary Measure 
....................             WRITE_SSP(data); 
....................             WAIT_FOR_SSP(); 
....................             return(READ_SSP()); 
....................         } 
....................     #else 
....................         int8 ssp_xfer(int8 data)  
....................         { 
....................             int ret; 
....................             ret = READ_SSP(); 
....................             WRITE_SSP(data); 
....................             SSPWCOL = 0;                // Precautionary Measure 
....................             return(ret); 
....................         } 
....................      
....................     #endif 
....................      
....................     #define ssp_get()        READ_SSP() 
....................     #define ssp_put(data)    WRITE_SSP(data) 
....................     #define ssp_clear()      SSPWCOL = 0; 
.................... #endif  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Initialize the pins that control the flash device. 
.................... //                This must be called before any other flash function is used. 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... // Dependencies:  None 
.................... //------------------------------------------------------------------------------ 
.................... void FGPA_SPI_Init(void) 
.................... { 
....................     Set_Tris_B(TRISB_Disable);           // Flash Disabled, turn on output pins 
*
0F8E:  MOVLW  0F
0F90:  MOVWF  F93
....................     Set_Tris_C(TRISC_Slave);           // Set up for SPI   
0F92:  MOVLW  08
0F94:  MOVWF  F94
.................... #if UseHWSPI 
....................     setup_spi(SPI_SLAVE | spi_h_to_l); 
0F96:  BCF    FC6.5
0F98:  MOVLW  34
0F9A:  MOVWF  FC6
0F9C:  MOVLW  40
0F9E:  MOVWF  FC7
....................     SSPCKP = 1;     // Clock Polarity Select bit, 1 = Idle state for clock is a high level 
0FA0:  BSF    FC6.4
....................     SSPSMP = 0;     // SMP: Sample bit Must be 0 in slave mode 
0FA2:  BCF    FC7.7
.................... #else 
....................     output_low(DEVICE_CLOCK); 
.................... #endif     
....................     output_high(DEVICE_SELECT); 
0FA4:  BSF    F89.5
....................      
....................     spi_enabled = True;             // Enable polling of SPI input      
0FA6:  BSF    2A.0
.................... } 
0FA8:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Disables Flash Functions to yeild to FPGA by tri-stating  
.................... //                FLASH_SELECT Line 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... // Dependencies:  None 
.................... //------------------------------------------------------------------------------ 
.................... void Disable_FGPA_SPI(void) 
.................... { 
....................     setup_spi(spi_ss_disabled); 
*
0D94:  BCF    FC6.5
0D96:  MOVLW  01
0D98:  MOVWF  FC6
0D9A:  MOVLW  00
0D9C:  MOVWF  FC7
....................     Set_Tris_B(TRISB_Disable);     // Flash Disabled, output pins Tristated  
0D9E:  MOVLW  0F
0DA0:  MOVWF  F93
....................     Set_Tris_C(TRISC_Disable);     // Flash Disabled  
0DA2:  MOVLW  88
0DA4:  MOVWF  F94
.................... #if UseHWSPI 
....................     setup_spi(SPI_SS_DISABLED); 
0DA6:  BCF    FC6.5
0DA8:  MOVLW  01
0DAA:  MOVWF  FC6
0DAC:  MOVLW  00
0DAE:  MOVWF  FC7
.................... #endif   
....................  
....................     spi_enabled = False;           // Disables polling of SPI input  
0DB0:  BCF    2A.0
.................... } 
0DB2:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Send data Byte to the flash device 
.................... // Inputs:        1) byte of data 
.................... // Outputs:       None 
.................... // Dependencies:  None 
.................... //------------------------------------------------------------------------------ 
.................... int8 FGPA_SPI_xferByte(int8 outdata) 
.................... { 
.................... #if UseHWSPI 
....................     return(ssp_xfer(outdata)); 
.................... #else 
....................    int8 i, indata8; 
....................     
....................    for(i=0; i<8; ++i) { 
....................       output_bit(DEVICE_DI, shift_left(&outdata,1,0));    // Send a data bit 
....................       output_high(DEVICE_CLOCK);                       // Pulse the clock 
....................       shift_left(&indata8, 1, input(DEVICE_DO)); 
....................       output_low(DEVICE_CLOCK); 
....................    } 
....................    return(indata8);    
.................... #endif 
.................... } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Send data Byte to the flash device 
.................... // Inputs:        1) byte of data 
.................... // Outputs:       None 
.................... // Dependencies:  None 
.................... //------------------------------------------------------------------------------ 
.................... void FGPA_SPI_sendByte(int8 data) 
.................... { 
.................... #if UseHWSPI 
....................     ssp_put(data); 
.................... #else 
....................    int8 i; 
....................     
....................    for(i=0; i<8; ++i) { 
....................       output_bit(DEVICE_DI, shift_left(&data,1,0));    // Send a data bit 
....................       output_high(DEVICE_CLOCK);                       // Pulse the clock 
....................       output_low(DEVICE_CLOCK); 
....................    } 
.................... #endif 
.................... } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Get a byte of data from the device.  
.................... // Inputs:        None 
.................... // Outputs:       1) A byte of data 
.................... // Dependencies:  None 
.................... //------------------------------------------------------------------------------ 
.................... int FGPA_SPI_getByte(void) 
.................... { 
.................... #if UseHWSPI 
....................     return(ssp_get()); 
.................... #else 
....................    int8 i, data; 
....................  
....................    for(i=0; i<8; ++i) {                       // Get 8 bits of data 
....................       output_high(DEVICE_CLOCK); 
....................       shift_left(&data, 1, input(DEVICE_DO)); 
....................       output_low(DEVICE_CLOCK); 
....................    } 
....................    return(data); 
.................... #endif 
.................... } 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //    End .h 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... #include "SST25V.h"             // Flash Memory Driver 
.................... //------------------------------------------------------------------------------ 
.................... // Library for an SST25V DataFlash                              
.................... // 
.................... // init_STFlash() - Initializes the pins that control the flash device. This must   
.................... //                  be called before any other flash function is used.              
.................... // 
.................... // BYTE STFlash_getByte() - Gets a byte of data from the flash device                      
.................... //                          Use after calling STFlash_startContinuousRead()               
.................... // 
.................... // void STFlash_getBytes(a, n) - Read n bytes and store in array a                               
.................... //                               Use after calling STFlash_startContinuousRead()               
.................... // 
.................... // void STFlash_readBuffer(b, i, a, n) - Read n bytes from buffer b at index i 
.................... //                                       and store in array a 
.................... // 
.................... // BYTE STFlash_readStatus() - Return the status of the flash device:   
.................... //                             Rdy/Busy Comp 0101XX 
.................... // 
.................... // void STFlash_writeToBuffer(b, i, a, n) - Write n bytes from array a to  
.................... //                                          buffer b at index i 
.................... // 
.................... // void STFlash_eraseBlock(b) - Erase all bytes in block b to 0xFF. A block is 256.     
.................... //  
.................... // The main program may define FLASH_SELECT, FLASH_CLOCK,    
.................... // FLASH_DI, and FLASH_DO to override the defaults below.   
.................... //                                       
.................... //                       Pin Layout                          
.................... //   ---------------------------------------------------     
.................... //   |    __                                           |  
.................... //   | 1: CS    FLASH_SELECT   | 8: VCC  +2.7V - +3.6V |  
.................... //   |                         |    ____               |   
.................... //   | 2: SO   FLASH_DO        | 7: HOLD  Hold         |    
.................... //   |    ___                  |                       |     
.................... //   | 3: WP    Write Protect  | 6: SCK   FLASH_CLOCK  |               
.................... //   |                         |    __                 |               
.................... //   | 4: Vss   Ground         | 5: SI     FLASH_DI    |               
.................... //   ---------------------------------------------------               
.................... //                                                                     
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //     * * * USER CONFIGURATION Section, set these per Hardware set up * * * 
.................... //------------------------------------------------------------------------------ 
.................... // FLASH_SIZE   4,194,304  bytes  
.................... //------------------------------------------------------------------------------ 
.................... #define SCLKDELAY    2  // Delay in cycles 
.................... #define SELSDELAY    1  // Delay in us 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Initialize the pins that control the flash device. 
.................... //                This must be called before any other flash function is used. 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... // Dependencies:  None 
.................... //------------------------------------------------------------------------------ 
.................... void Init_STFlash(void) 
.................... { 
....................     Set_Tris_B(TRISB_Master);     // Flash Disabled, turn on output pins 
*
0DDC:  MOVLW  08
0DDE:  MOVWF  F93
....................     Set_Tris_C(TRISC_Master);     // Set up for PIC being Master  
0DE0:  MOVLW  88
0DE2:  MOVWF  F94
....................     output_high(FLASH_SELECT);    // FLASH_SELECT high 
0DE4:  BSF    F8A.2
....................     output_low(FLASH_CLOCK);     // Clock High 
0DE6:  BCF    F8A.1
.................... } 
0DE8:  GOTO   0E6E (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Disables Flash Functions to yeild to FPGA by tri-stating  
.................... //                FLASH_SELECT Line 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... // Dependencies:  None 
.................... //------------------------------------------------------------------------------ 
.................... void Disable_STFlash(void) 
.................... { 
....................     Set_Tris_C(TRISC_Disable);     // Set up for PIC being Master  
*
0F84:  MOVLW  88
0F86:  MOVWF  F94
....................     Set_Tris_B(TRISB_Disable);     // Flash Disabled, output pins Tristated 
0F88:  MOVLW  0F
0F8A:  MOVWF  F93
.................... } 
0F8C:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Select the flash device 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... //------------------------------------------------------------------------------ 
.................... void chip_select(void) 
.................... { 
....................    output_low(FLASH_CLOCK); 
*
0DEC:  BCF    F8A.1
....................    output_low(FLASH_SELECT);            // Enable select line 
0DEE:  BCF    F8A.2
....................    delay_us(SELSDELAY);                 // Settling time 
0DF0:  MOVLW  03
0DF2:  MOVWF  00
0DF4:  DECFSZ 00,F
0DF6:  BRA    0DF4
0DF8:  BRA    0DFA
.................... } 
0DFA:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Deselect the flash device 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... //------------------------------------------------------------------------------ 
.................... void chip_deselect(void) 
.................... { 
....................    output_high(FLASH_SELECT);           // Disable select line 
*
0E44:  BSF    F8A.2
....................    output_low(FLASH_CLOCK);            // Pulse the clock 
0E46:  BCF    F8A.1
....................    delay_us(SELSDELAY);                 // Settling time 
0E48:  MOVLW  03
0E4A:  MOVWF  00
0E4C:  DECFSZ 00,F
0E4E:  BRA    0E4C
0E50:  BRA    0E52
.................... } 
0E52:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Send data Byte to the flash device 
.................... // Inputs:        1 byte of data 
.................... // Outputs:       None 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_SendByte(int8 data) 
.................... { 
....................     int8 i; 
....................     for(i=0; i<8; i++) { 
*
0DFC:  CLRF   xEB
0DFE:  MOVF   xEB,W
0E00:  SUBLW  07
0E02:  BNC   0E1C
....................         output_bit(FLASH_DI, shift_left(&data,1,0));    // Send a data bit 
0E04:  BCF    FD8.0
0E06:  RLCF   xEA,F
0E08:  BC    0E0E
0E0A:  BCF    F8A.0
0E0C:  BRA    0E10
0E0E:  BSF    F8A.0
....................         output_high(FLASH_CLOCK);                       // Pulse the clock 
0E10:  BSF    F8A.1
....................         delay_cycles(SCLKDELAY);                        // Same as a NOP 
0E12:  BRA    0E14
....................         output_low(FLASH_CLOCK); 
0E14:  BCF    F8A.1
....................         delay_cycles(SCLKDELAY);                        // Same as a NOP 
0E16:  BRA    0E18
....................    } 
0E18:  INCF   xEB,F
0E1A:  BRA    0DFE
.................... } 
0E1C:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Receive data Byte from the flash device 
.................... // Inputs:        None 
.................... // Outputs:       1 byte of data 
.................... // Dependencies:  Must enter with Clock high (preceded by a send) 
.................... //------------------------------------------------------------------------------ 
.................... int8 STFlash_GetByte(void) 
.................... { 
....................    int8 i, flashData; 
....................    for(i=0; i<8; i++) { 
0E1E:  CLRF   xE0
0E20:  MOVF   xE0,W
0E22:  SUBLW  07
0E24:  BNC   0E3E
....................        output_high(FLASH_CLOCK);                       // Pulse the clock 
0E26:  BSF    F8A.1
....................        delay_cycles(SCLKDELAY);                        // Same as a NOP 
0E28:  BRA    0E2A
....................        shift_left(&flashData, 1, input(FLASH_DO));       
0E2A:  BTFSC  F82.7
0E2C:  BRA    0E32
0E2E:  BCF    FD8.0
0E30:  BRA    0E34
0E32:  BSF    FD8.0
0E34:  RLCF   xE1,F
....................        output_low(FLASH_CLOCK); 
0E36:  BCF    F8A.1
....................        delay_cycles(SCLKDELAY);                        // Same as a NOP 
0E38:  BRA    0E3A
....................    } 
0E3A:  INCF   xE0,F
0E3C:  BRA    0E20
....................    return(flashData); 
0E3E:  MOVFF  E1,01
.................... } 
0E42:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Get a byte of data from the flash device. This function is 
.................... //                meant to be used after STFlash_startContinuousRead() has 
.................... //                been called to initiate a continuous read. This function is 
.................... //                also used by STFlash_readPage() and STFlash_readBuffer(). 
.................... // Inputs:        1) A pointer to an array to fill 
.................... //                2) The number of bytes of data to read 
.................... // Outputs:       None 
.................... // Dependencies:  None 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_getBytes(int8 *data, int16 size) 
.................... { 
....................    int16 i; 
....................    int8  j; 
....................    for(i=0; i<size; i++) { 
*
12F6:  CLRF   xE2
12F8:  CLRF   xE1
12FA:  MOVF   xE2,W
12FC:  SUBWF  xE0,W
12FE:  BNC   1344
1300:  BNZ   1308
1302:  MOVF   xDF,W
1304:  SUBWF  xE1,W
1306:  BC    1344
....................       for(j=0; j<8; j++) { 
1308:  CLRF   xE3
130A:  MOVF   xE3,W
130C:  SUBLW  07
130E:  BNC   133C
....................          output_high(FLASH_CLOCK); 
1310:  BSF    F8A.1
....................          delay_cycles(SCLKDELAY);                   // Small delay NOP 
1312:  BRA    1314
....................          shift_left(data+i, 1, input(FLASH_DO)); 
1314:  MOVF   xE1,W
1316:  ADDWF  xDD,W
1318:  MOVWF  xE4
131A:  MOVF   xE2,W
131C:  ADDWFC xDE,W
131E:  MOVWF  xE5
1320:  BTFSC  F82.7
1322:  BRA    1328
1324:  BCF    FD8.0
1326:  BRA    132A
1328:  BSF    FD8.0
132A:  MOVFF  E5,FEA
132E:  MOVFF  E4,FE9
1332:  RLCF   FEF,F
....................          output_low(FLASH_CLOCK); 
1334:  BCF    F8A.1
....................          delay_cycles(SCLKDELAY);                   // Same as a NOP 
1336:  BRA    1338
....................       } 
1338:  INCF   xE3,F
133A:  BRA    130A
....................    } 
133C:  INCF   xE1,F
133E:  BTFSC  FD8.2
1340:  INCF   xE2,F
1342:  BRA    12FA
.................... } 
1344:  GOTO   1380 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Return the Read status Register of the flash device 
.................... // Inputs:        None            ____ 
.................... // Outputs:       The Read status 
.................... // Dependencies:  STFlash_sendData(), STFlash_getByte() 
.................... //------------------------------------------------------------------------------ 
.................... int8 STFlash_readStatus() 
.................... { 
....................    int8 status; 
....................    chip_select();                  // Enable select line 
*
0E54:  RCALL  0DEC
....................    STFlash_SendByte(0x05);         // Send status command 
0E56:  MOVLW  05
0E58:  MOVWF  xEA
0E5A:  RCALL  0DFC
....................    status = STFlash_GetByte();     // Get the status 
0E5C:  RCALL  0E1E
0E5E:  MOVFF  01,DF
....................    chip_deselect();                // Disable select line 
0E62:  RCALL  0E44
....................    return(status);                 // Return the status 
0E64:  MOVFF  DF,01
.................... } 
0E68:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Wait until the flash device is ready to accept commands 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... // Dependencies:  STFlash_sendData() 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_waitUntilReady(void) 
.................... { 
....................    chip_select();                  // Enable select line 
....................    STFlash_sendByte(0x05);         // Send status command 
....................    while(input(FLASH_DO));         // Wait until ready 
....................    STFlash_GetByte();              // Get byte  
....................    chip_deselect();                // Disable select line 
.................... } 
....................  
.................... //---------------------------------------------------------------------------- 
.................... // Purpose:       Enable Page Program write 
.................... // Inputs:        None. 
.................... // Outputs:       None. 
.................... // Dependencies:  STFlash_sendData(), STFlash_waitUntilReady() 
.................... //---------------------------------------------------------------------------- 
.................... void STFlash_WriteEnable(void) 
.................... { 
....................    chip_select();                  // Enable select line 
*
12AC:  RCALL  0DEC
....................    STFlash_sendByte(0x06);         // Send opcode 
12AE:  MOVLW  06
12B0:  MOVWF  xEA
12B2:  RCALL  0DFC
....................    chip_deselect();                // Disable select line 
12B4:  RCALL  0E44
.................... } 
12B6:  RETLW  00
....................  
.................... //---------------------------------------------------------------------------- 
.................... // Purpose:       Disable Page Program write 
.................... // Inputs:        None. 
.................... // Outputs:       None. 
.................... // Dependencies:  STFlash_sendData(), STFlash_waitUntilReady() 
.................... //---------------------------------------------------------------------------- 
.................... void STFlash_WriteDisable(void) 
.................... { 
....................    chip_select();                  // Enable select line 
12B8:  RCALL  0DEC
....................    STFlash_sendByte(0x04);         // Send opcode 
12BA:  MOVLW  04
12BC:  MOVWF  xEA
12BE:  RCALL  0DFC
....................    chip_deselect();                // Disable select line 
12C0:  RCALL  0E44
.................... } 
12C2:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Write a byte to the status register of the flash device 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... // Dependencies:  STFlash_sendData(), STFlash_getByte() 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_writeStatus(int8 value) 
.................... { 
....................    STFlash_WriteEnable();          // Enable b yte writting 
*
14BA:  RCALL  12AC
....................    chip_select();                  // Enable select line 
14BC:  RCALL  0DEC
....................    STFlash_sendByte(0x01);         // Send status command 
14BE:  MOVLW  01
14C0:  MOVWF  xEA
14C2:  RCALL  0DFC
....................    STFlash_sendByte(value);        // Send status value 
14C4:  MOVFF  8D,EA
14C8:  RCALL  0DFC
....................    chip_deselect();                // Disable select line 
14CA:  RCALL  0E44
....................    STFlash_WriteDisable();         // Disable writting 
14CC:  RCALL  12B8
.................... } 
14CE:  GOTO   17F6 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Reads a block of data (usually 256 bytes) from the ST 
.................... //                Flash and into a buffer pointed to by int Buffer; 
.................... // 
.................... // Inputs:        1) Address of block to read from 
.................... //                2) A pointer to an array to fill 
.................... //                3) The number of bytes of data to read 
.................... // Outputs:       None 
.................... // Dependencies:  STFlash_sendData(), STFlash_getByte() 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_ReadBlock(int32 Address, int8 *buffer, int16 size) 
.................... { 
....................    chip_select();                         // Enable select line 
*
1348:  RCALL  0DEC
....................    STFlash_sendByte(0x03);                // Send opcode 
134A:  MOVLW  03
134C:  MOVWF  xEA
134E:  RCALL  0DFC
....................    STFlash_sendByte(Make8(Address, 2));   // Send address  
1350:  MOVFF  D7,DD
1354:  MOVFF  D7,EA
1358:  RCALL  0DFC
....................    STFlash_sendByte(Make8(Address, 1));   // Send address 
135A:  MOVFF  D6,DD
135E:  MOVFF  D6,EA
1362:  RCALL  0DFC
....................    STFlash_sendByte(Make8(Address, 0));   // Send address 
1364:  MOVFF  D5,DD
1368:  MOVFF  D5,EA
136C:  RCALL  0DFC
....................    STFlash_getBytes(buffer, size);        // Get bytes into buffer 
136E:  MOVFF  DA,DE
1372:  MOVFF  D9,DD
1376:  MOVFF  DC,E0
137A:  MOVFF  DB,DF
137E:  BRA    12F6
....................    chip_deselect();                       // Disable select line 
1380:  RCALL  0E44
.................... } 
1382:  GOTO   13A4 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Send some bytes of data to the flash device 
.................... // Inputs:        1) A pointer to an array of data to send 
.................... //                2) The number of bytes to send 
.................... // Outputs:       None 
.................... // Dependencies:  None 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_Write1Byte(int32 Address, int8 data) 
.................... { 
....................    STFlash_WriteEnable();                 // Write 1 byte to specified address 
*
13BE:  RCALL  12AC
....................    chip_select();                         // Enable select line 
13C0:  RCALL  0DEC
....................    STFlash_sendByte(0x02);                // Send Opcode 
13C2:  MOVLW  02
13C4:  MOVWF  xEA
13C6:  RCALL  0DFC
....................    STFlash_sendByte(Make8(Address, 2));   // Send Address  
13C8:  MOVFF  E6,E9
13CC:  MOVFF  E6,EA
13D0:  RCALL  0DFC
....................    STFlash_sendByte(Make8(Address, 1));   // Send Address 
13D2:  MOVFF  E5,E9
13D6:  MOVFF  E5,EA
13DA:  RCALL  0DFC
....................    STFlash_sendByte(Make8(Address, 0));   // Send Address 
13DC:  MOVFF  E4,E9
13E0:  MOVFF  E4,EA
13E4:  RCALL  0DFC
....................    STFlash_SendByte(data);                // Send Data 
13E6:  MOVFF  E8,EA
13EA:  RCALL  0DFC
....................    chip_deselect();                       // Disable select line 
13EC:  RCALL  0E44
.................... } 
13EE:  GOTO   1442 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Writes a block of data (usually 256 bytes) to the ST 
.................... //                Flash from a buffer pointed to by int Buffer; 
.................... // 
.................... // Inputs:        1) Address of block to read from 
.................... //                2) A pointer to an array to fill 
.................... //                3) The number of bytes of data to read 
.................... // Outputs:       None 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_WriteBlock(int32 Address, int8 *buffer, int16 size) 
.................... { 
....................     int16 i; 
....................     for(i = 0; i < size; i++) { 
13F2:  CLRF   xDE
13F4:  CLRF   xDD
13F6:  MOVF   xDE,W
13F8:  SUBWF  xDC,W
13FA:  BNC   145A
13FC:  BNZ   1404
13FE:  MOVF   xDB,W
1400:  SUBWF  xDD,W
1402:  BC    145A
....................        STFlash_Write1Byte(Address+i, buffer[i]); 
1404:  MOVF   xDD,W
1406:  ADDWF  xD5,W
1408:  MOVWF  xDF
140A:  MOVF   xDE,W
140C:  ADDWFC xD6,W
140E:  MOVWF  xE0
1410:  MOVLW  00
1412:  ADDWFC xD7,W
1414:  MOVWF  xE1
1416:  MOVLW  00
1418:  ADDWFC xD8,W
141A:  MOVWF  xE2
141C:  MOVF   xD9,W
141E:  ADDWF  xDD,W
1420:  MOVWF  FE9
1422:  MOVF   xDA,W
1424:  ADDWFC xDE,W
1426:  MOVWF  FEA
1428:  MOVFF  FEF,E3
142C:  MOVFF  E2,E7
1430:  MOVFF  E1,E6
1434:  MOVFF  E0,E5
1438:  MOVFF  DF,E4
143C:  MOVFF  E3,E8
1440:  BRA    13BE
....................        delay_us(10); 
1442:  MOVLW  27
1444:  MOVWF  00
1446:  DECFSZ 00,F
1448:  BRA    1446
144A:  BRA    144C
....................        while(STFlash_readStatus() & 0x01); 
144C:  RCALL  0E54
144E:  BTFSC  01.0
1450:  BRA    144C
....................     } 
1452:  INCF   xDD,F
1454:  BTFSC  FD8.2
1456:  INCF   xDE,F
1458:  BRA    13F6
....................     STFlash_WriteDisable(); 
145A:  RCALL  12B8
.................... } 
145C:  GOTO   1498 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Purpose:       Erase a block of data (usually 256 bytes) 
.................... // 
.................... // Inputs:        1) Address of block to erase 
.................... // Outputs:       None 
.................... //------------------------------------------------------------------------------ 
.................... void STFlash_EraseBlock(int32 Address) 
.................... { 
....................  
....................    STFlash_WriteEnable();                // Enable b yte writting 
*
12C4:  RCALL  12AC
....................    chip_select();                        // Enable select line 
12C6:  RCALL  0DEC
....................    STFlash_sendByte(0xD8);               // Send opcode 
12C8:  MOVLW  D8
12CA:  MOVWF  xEA
12CC:  RCALL  0DFC
....................    STFlash_sendByte(Make8(Address, 2));  // Send address  
12CE:  MOVFF  93,95
12D2:  MOVFF  93,EA
12D6:  RCALL  0DFC
....................    STFlash_sendByte(Make8(Address, 1));  // Send address 
12D8:  MOVFF  92,95
12DC:  MOVFF  92,EA
12E0:  RCALL  0DFC
....................    STFlash_sendByte(Make8(Address, 0));  // Send address 
12E2:  MOVFF  91,95
12E6:  MOVFF  91,EA
12EA:  RCALL  0DFC
....................    output_high(FLASH_SELECT);            // Disable select line 
12EC:  BSF    F8A.2
....................    chip_deselect();                      // Disable select line 
12EE:  RCALL  0E44
....................    STFlash_WriteDisable();               // Disable writting 
12F0:  RCALL  12B8
.................... } 
12F2:  GOTO   17F6 (RETURN)
....................  
.................... //---------------------------------------------------------------------------- 
.................... //  End .h 
.................... //---------------------------------------------------------------------------- 
....................  
.................... #include "DS1302.h"             // Real Time Clock 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // D S 1 3 0 2      R T C    C o n t r o l     R o u t i n e s :              
.................... // 
.................... // Interface to the Dallas Maxim DS1302 
.................... // 
.................... // Use Standard IO (Let CCS determine TRIS Setup) 
.................... // Define IO pins as needed. 
.................... // 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... #define RtcRstBit     RTC_RST                   // RTC reset line LO=reset HI=active 
.................... #define RtcClkBit     RTC_SCLK                  // RTC clock pin 
.................... #define RtcSioBit     RTC_SIO                   // RTC I/O data pin 
.................... //------------------------------------------------------------------------------ 
.................... //   DS1302 Register definintions:                                              
.................... //------------------------------------------------------------------------------ 
.................... #define RTC_Reg      0x80                       // Real Time Clock base register 
.................... #define RTC_RD       0x01                       // Read bit 
.................... #define RTC_WR       0x00                       // Write bit 
.................... //------------------------------------------------------------------------------ 
.................... #define RTC_Sec      0x00                       // Seconds 
.................... #define RTC_Min      0x01                       // Minutes Write 
.................... #define RTC_Hrs      0x02                       // Hours Write 
.................... #define RTC_Dat      0x03                       // Date Write 
.................... #define RTC_Mon      0x04                       // Month Write 
.................... #define RTC_Day      0x05                       // Day Write 
.................... #define RTC_Yrs      0x06                       // Years Write 
.................... #define RTC_Ctl      0x07                       // Control Write 
.................... #define RTC_Trc      0x08                       // Trickle Charge Control Write 
.................... #define RTC_Bst      0x1F                       // RAM Burst Control Write 
.................... #define RTC_RAMS     0x20                       // Scratch Pad Start 
.................... //------------------------------------------------------------------------------ 
.................... //  Alarm Time Locations                                                      
.................... //------------------------------------------------------------------------------ 
.................... #define Alm_ENB      0x20                        // Flag to enable/disable alrms 
.................... #define Alm_RHr      0x21                        // Sunrise Time Hours 
.................... #define Alm_RMn      0x22                        // Sunrise Time Minutes 
.................... #define Alm_SHr      0x23                        // Sunset  Time Hours 
.................... #define Alm_SMn      0x24                        // Sunset  Time Minutes 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //   Write 1 byte to RTC Pipe:                                                  
.................... //------------------------------------------------------------------------------ 
.................... void RtcWrByte(int SData) 
.................... { 
....................     int i; 
....................     for(i=0; i<8; ++i) { 
*
0C66:  CLRF   xD3
0C68:  MOVF   xD3,W
0C6A:  SUBLW  07
0C6C:  BNC   0C82
....................         output_bit(RtcSioBit, shift_right(&SData,1,0));  // Send a data bit 
0C6E:  BCF    FD8.0
0C70:  RRCF   xD2,F
0C72:  BC    0C78
0C74:  BCF    F8B.1
0C76:  BRA    0C7A
0C78:  BSF    F8B.1
....................         output_low(RtcClkBit); 
0C7A:  BCF    F8B.0
....................         output_high(RtcClkBit);                          // Pulse the clock 
0C7C:  BSF    F8B.0
....................     } 
0C7E:  INCF   xD3,F
0C80:  BRA    0C68
.................... } 
0C82:  RETLW  00
.................... //------------------------------------------------------------------------------ 
.................... //   Read 1 byte from RTC Pipe:                                                  
.................... //------------------------------------------------------------------------------ 
.................... int RtcRdByte(void) 
.................... { 
....................     int i, SData; 
....................     for(i=0; i<8; ++i) {                        // Get 8 bits of data 
0C84:  CLRF   xD2
0C86:  MOVF   xD2,W
0C88:  SUBLW  07
0C8A:  BNC   0CAC
....................         output_low(RtcClkBit); 
0C8C:  BCF    F8B.0
....................         set_tris_C(get_tris_C() | 0b00000010); 
0C8E:  MOVF   F94,W
0C90:  IORLW  02
0C92:  MOVWF  F94
....................         shift_right(&SData, 1, input(RtcSioBit)); 
0C94:  BTFSC  F82.1
0C96:  BRA    0C9C
0C98:  BCF    FD8.0
0C9A:  BRA    0C9E
0C9C:  BSF    FD8.0
0C9E:  RRCF   xD3,F
....................         set_tris_C(get_tris_C() & 0b11111101); 
0CA0:  MOVF   F94,W
0CA2:  ANDLW  FD
0CA4:  MOVWF  F94
....................         output_high(RtcClkBit); 
0CA6:  BSF    F8B.0
....................     } 
0CA8:  INCF   xD2,F
0CAA:  BRA    0C86
....................     return(SData); 
0CAC:  MOVFF  D3,01
.................... } 
0CB0:  GOTO   0CD4 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //   Write 1 Byte to RTC register:                                              
.................... //------------------------------------------------------------------------------ 
.................... void RTCWrite(int addr, int data) 
.................... { 
....................     output_low(RtcClkBit);      // Clock pin low 
*
155E:  BCF    F8B.0
....................     output_low(RtcSioBit);      // Start with IO pin low 
1560:  BCF    F8B.1
....................     delay_us(20);               // Time delay to allow time for Data clock setup 
1562:  MOVLW  4F
1564:  MOVWF  00
1566:  DECFSZ 00,F
1568:  BRA    1566
156A:  BRA    156C
....................     output_high(RtcRstBit);     // Raise RTC Reset pin to enable interface 
156C:  BSF    F8B.2
....................     addr = addr<<1;             // Rotate left 
156E:  BCF    FD8.0
1570:  RLCF   x92,F
....................     addr |= RTC_Reg | RTC_WR;   // Make the address byte 
1572:  BSF    x92.7
....................     RtcWrByte(addr);            // Write address pointer byte out serial pipe 
1574:  MOVFF  92,D2
1578:  CALL   0C66
....................     RtcWrByte(data);            // Write data byte out serial pipe 
157C:  MOVFF  93,D2
1580:  CALL   0C66
....................     output_low(RtcRstBit);      // Lower RTC Reset pin to dis-able interface 
1584:  BCF    F8B.2
.................... } 
1586:  RETLW  00
.................... //------------------------------------------------------------------------------ 
.................... //  Read 1 byte from RTC:                                                      
.................... //------------------------------------------------------------------------------ 
.................... int RTCRead(int addr) 
.................... { 
....................     int data; 
....................  
....................     output_low(RtcClkBit);      // Clock pin low 
*
0CB4:  BCF    F8B.0
....................     output_low(RtcSioBit);      // Start with IO pin low 
0CB6:  BCF    F8B.1
....................     delay_us(20);               // Time delay to allow time for Data clock setup 
0CB8:  MOVLW  4F
0CBA:  MOVWF  00
0CBC:  DECFSZ 00,F
0CBE:  BRA    0CBC
0CC0:  BRA    0CC2
....................     output_high(RtcRstBit);     // Raise RTC Reset pin to enable interface 
0CC2:  BSF    F8B.2
....................     addr = addr<<1;             // Rotate left 
0CC4:  BCF    FD8.0
0CC6:  RLCF   xD0,F
....................     addr |= RTC_Reg | RTC_RD;   // Make the address byte 
0CC8:  MOVLW  81
0CCA:  IORWF  xD0,F
....................     RtcWrByte(addr);            // Write address pointer byte out serial pipe 
0CCC:  MOVFF  D0,D2
0CD0:  RCALL  0C66
....................     data = RtcRdByte();         // Read data from Serial pipe 
0CD2:  BRA    0C84
0CD4:  MOVFF  01,D1
....................     output_low(RtcRstBit);      // Lower RTC Reset pin to dis-able interface 
0CD8:  BCF    F8B.2
....................     return(data);               // Return the result 
0CDA:  MOVFF  D1,01
.................... } 
0CDE:  RETLW  00
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // 
.................... //  F u n c t i o n     P r o t o t y p e s: 
.................... // 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... //  E E P R O M    C o n t r o l     F u n c t i o n s 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // EEPROM Memory Map : 
.................... // PIC EEPROM is non-volital memory used store various parameters and  
.................... // prescriptions for the boot up and control of ZBC. 
.................... //------------------------------------------------------------------------------ 
.................... //   Start    End  Size Description 
.................... // ------- ------- ---- ------------------------------------------------------ 
.................... //    0x00    0x02    3 Start address of Bios File 
.................... //    0x03    0x05    3 End   address of Bios File 
.................... //    0x06    0x08    3 Start address of Floppy File 
.................... //    0x09    0x0B    3 End   address of Floppy File 
.................... //    0x0C    0x0E    3 Start address of RBF File 
.................... //    0x0F    0x11    3 End   address of RBF File 
.................... // 
.................... //    0x12    0x12    1 Boot type, 0= No boot (debug), 1=HD, 2= Floppy,  
.................... //------------------------------------------------------------------------------ 
.................... #define S_ADDR_BIOS   0x00      // Start address of Bios File  
.................... #define E_ADDR_BIOS   0x03      // End   address of Bios File 
.................... #define S_ADDR_FLOPPY 0x06      // Start address of Floppy File 
.................... #define E_ADDR_FLOPPY 0x09      // End   address of Floppy File 
.................... #define S_ADDR_RBF    0x0C      // Start address of RBF File 
.................... #define E_ADDR_RBF    0x0F      // End   address of RBF File  
.................... #define BOOT_TYPE     0x12      // Boot type indicator 
....................  
.................... //------------------------------------------------------------------------------ 
.................... void Get_EEPROM(int address) 
.................... { 
....................     int Buffer[blksize];          // Buffer for data  
....................     Buffer[0] = read_eeprom(address); 
*
124E:  MOVFF  FF2,CE
1252:  BCF    FF2.7
1254:  MOVFF  8D,FA9
1258:  BCF    FA6.6
125A:  BCF    FA6.7
125C:  BSF    FA6.0
125E:  MOVF   FA8,W
1260:  BTFSC  xCE.7
1262:  BSF    FF2.7
1264:  MOVWF  x8E
....................     Buffer[1] = 'E'; 
1266:  MOVLW  45
1268:  MOVWF  x8F
....................     usb_put_packet(1, Buffer, blksize ,USB_DTS_TOGGLE); 
126A:  MOVLW  01
126C:  MOVWF  xD6
126E:  CLRF   xD8
1270:  MOVLW  8E
1272:  MOVWF  xD7
1274:  CLRF   xDA
1276:  MOVLW  40
1278:  MOVWF  xD9
127A:  MOVLW  02
127C:  MOVWF  xDB
127E:  RCALL  0E8C
.................... } 
1280:  GOTO   17F6 (RETURN)
.................... //------------------------------------------------------------------------------ 
.................... // Get a 24 bit parm from EEPROM 
.................... //------------------------------------------------------------------------------ 
.................... int32 get_ee_24(int address)    
.................... { 
....................     return(make32(0,read_eeprom(address),read_eeprom(address+1),read_eeprom(address+2))); 
*
0D3C:  MOVFF  FF2,97
0D40:  BCF    FF2.7
0D42:  MOVFF  96,FA9
0D46:  BCF    FA6.6
0D48:  BCF    FA6.7
0D4A:  BSF    FA6.0
0D4C:  MOVF   FA8,W
0D4E:  BTFSC  x97.7
0D50:  BSF    FF2.7
0D52:  MOVWF  x98
0D54:  MOVLW  01
0D56:  ADDWF  x96,W
0D58:  MOVFF  FF2,9A
0D5C:  BCF    FF2.7
0D5E:  MOVWF  FA9
0D60:  BCF    FA6.6
0D62:  BCF    FA6.7
0D64:  BSF    FA6.0
0D66:  MOVF   FA8,W
0D68:  BTFSC  x9A.7
0D6A:  BSF    FF2.7
0D6C:  MOVWF  x9A
0D6E:  MOVLW  02
0D70:  ADDWF  x96,W
0D72:  MOVFF  FF2,9C
0D76:  BCF    FF2.7
0D78:  MOVWF  FA9
0D7A:  BCF    FA6.6
0D7C:  BCF    FA6.7
0D7E:  BSF    FA6.0
0D80:  MOVF   FA8,W
0D82:  BTFSC  x9C.7
0D84:  BSF    FF2.7
0D86:  CLRF   03
0D88:  MOVFF  98,02
0D8C:  MOVFF  9A,01
0D90:  MOVWF  00
.................... } 
0D92:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... //  Upload FPGA Firware  
.................... //  Un-comment these lines and set them according to your application. 
.................... // 
.................... // #define FPGAClock   PIN_xx      // FPGA Serial upload clock line 
.................... // #define FPGADOut    PIN_xx      // FPGA Serial upload data line 
.................... // #define FPGALoad    PIN_xx      // FPGA Serial upload select line 
.................... // #define FPGAReset   PIN_xx      // Reset 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... //  Upload FPGA Firware  
.................... //------------------------------------------------------------------------------ 
.................... #define USEASM      1               // Use Assembly for speed 
.................... #define IOPORT      0xF81           // IO Port, A=F80, B=F81, C=F82, D=F83, E=F84 
.................... #define FPGAce      5               // FPGA Config line LO=reset HI=active 
.................... #define FPGAsio     6               // FPGA I/O data ( pin 76) 
.................... #define FPGAclk     7               // FPGA clock ( pin  75) 
.................... #define FPGA_SIO    IOPORT,FPGAsio  // FPGA SIO line LO=reset HI=active 
.................... #define FPGA_CLK    IOPORT,FPGAclk  // FPGA clock line 
.................... //-------------------------------------------------------------------------- 
.................... void LoadFPGAByte(byte Sdata) 
.................... { 
.................... #if USEASM 
....................     int8  Rbit, Rdata; 
....................     #asm 
....................             Movf    Sdata,W         // Store it for later 
*
0F68:  MOVF   xD7,W
....................             Movwf   Rdata           // Tempstore data 
0F6A:  MOVWF  xD9
....................             Movlw   0x08            // Number of bits to send 
0F6C:  MOVLW  08
....................             Movwf   Rbit            // Save it 
0F6E:  MOVWF  xD8
....................     WBit:   Btfss   Rdata,0         // Check next bit 
0F70:  BTFSS  xD9.0
....................             Bcf     FPGA_SIO        // If clear send a zero 
0F72:  BCF    F81.6
....................             Btfsc   Rdata,0         // Check next bit 
0F74:  BTFSC  xD9.0
....................             Bsf     FPGA_SIO        // If set send a one 
0F76:  BSF    F81.6
....................             Bsf     FPGA_CLK        // Clock pin high 
0F78:  BSF    F81.7
....................             Rrcf    Rdata,F         // Rotate for next bit 
0F7A:  RRCF   xD9,F
....................             Bcf     FPGA_CLK        // Raise clock pin 
0F7C:  BCF    F81.7
....................             Decfsz  Rbit,F          // Decrement bit counter 
0F7E:  DECFSZ xD8,F
....................             Goto    WBit            // Do next bit 
0F80:  BRA    0F70
....................     #endasm 
.................... #else 
....................     int8 i; 
....................     for(i=0; i<8; ++i) { 
....................         output_bit(FPGADOut, shift_right(&SData,1,0));  // Send a data bit 
....................         output_low(FPGAClock); 
....................         output_high(FPGAClock);                         // Pulse the clock 
....................     } 
.................... #endif 
.................... } 
0F82:  RETLW  00
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //---------------------------------------------------------------------------- 
.................... //---------------------------------------------------------------------------- 
.................... //  S T    F l a s h    F u n c t i  o n s                                      
.................... //---------------------------------------------------------------------------- 
.................... //---------------------------------------------------------------------------- 
....................  
.................... //--------------------------------------------------------------------------- 
.................... //------------------------------------------------------------------------------ 
.................... // Flash RAM Memory Map 32Mb (4Mbyte) Chip: 
.................... //------------------------------------------------------------------------------ 
.................... // REMEMBER - Actual Virtual Floppy File size = 1,474,560 = 0x16_8000 
.................... // 
.................... //     Start      End      Start       End      File       Hex   64k 
.................... //   Address   Address   Address   Address      Size      Size Blcks Description 
.................... // --------- --------- --------- --------- --------- --------- ----- ----------- 
.................... //         0   131,071 0x00_0000 0x01_FFFF   131,071 0x02_0000   2.0 BIOS ROM 
.................... //   131,072 1,605,631 0x02_0000 0x18_7FFF 1,474,560 0x16_8000  22.5 Floppy 
.................... // 1,605,632 1,638,399 0x18_8000 0x18_FFFF    32,768 0x00_8000    .5 Round to 64k block 
.................... // 1,571,072 2,097,151 0x19_0000 0x1F_FFFF   458,752 0x07_0000   7.0 RBF, actual size varies 
.................... // 
.................... // 2,097,152 2,228,223 0x20_0000 0x21_FFFF   131,071 0x02_0000   2.0 BIOS ROM#2 
.................... // 2,228,223 3,702,783 0x22_0000 0x38_7FFF 1,474,560 0x16_8000  22.5 Floppy #2 
.................... // 3,702,784 3,735,551 0x38_8000 0x38_FFFF    32,768 0x00_8000    .5 Round to 64k block 
.................... // 3,735,552 4,097,151 0x39_0000 0x3F_FFFF   458,752 0x07_0000   7.0 RBF, actual size varies 
.................... // 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //-------------------------------------------------------------------------- 
.................... // Initialize ST Flash RAM with retries,  
.................... // tries = number of times to retry befor giving up 
.................... //-------------------------------------------------------------------------- 
.................... short Try_Init_Flash(int tries) 
.................... { 
....................     short ret = 1; 
*
0E6A:  BSF    xD7.0
....................     do { 
....................         Init_STFlash();                 // Initialize ST Card 
0E6C:  BRA    0DDC
....................         if(STFlash_readStatus() == 0) { // Check Status of ST FLASH 
0E6E:  RCALL  0E54
0E70:  MOVF   01,F
0E72:  BNZ   0E78
....................             ret = 0; 
0E74:  BCF    xD7.0
....................             break; 
0E76:  BRA    0E80
....................         } 
....................     } while(tries--); 
0E78:  MOVF   xD6,W
0E7A:  DECF   xD6,F
0E7C:  XORLW  00
0E7E:  BNZ   0E6C
....................     return(ret); 
0E80:  MOVLW  00
0E82:  BTFSC  xD7.0
0E84:  MOVLW  01
0E86:  MOVWF  01
.................... } 
0E88:  GOTO   0F44 (RETURN)
....................  
.................... //-------------------------------------------------------------------------- 
.................... // Initialize ST Flash RAM 
.................... //-------------------------------------------------------------------------- 
.................... void Init_Flash(void) 
.................... { 
....................     int   Buffer[blksize];          // Buffer for data  
....................     Buffer[0] = Try_Init_Flash(3);  
*
0F3E:  MOVLW  03
0F40:  MOVWF  xD6
0F42:  BRA    0E6A
0F44:  MOVFF  01,96
....................     Buffer[1] = Buffer[0];  
0F48:  MOVFF  96,97
....................     Buffer[2] = 'I';  
0F4C:  MOVLW  49
0F4E:  MOVWF  x98
....................     usb_put_packet(1, Buffer, blksize ,USB_DTS_TOGGLE); 
0F50:  MOVLW  01
0F52:  MOVWF  xD6
0F54:  CLRF   xD8
0F56:  MOVLW  96
0F58:  MOVWF  xD7
0F5A:  CLRF   xDA
0F5C:  MOVLW  40
0F5E:  MOVWF  xD9
0F60:  MOVLW  02
0F62:  MOVWF  xDB
0F64:  RCALL  0E8C
.................... } 
0F66:  RETLW  00
....................  
.................... //-------------------------------------------------------------------------- 
.................... //    Get Status Register 
.................... //-------------------------------------------------------------------------- 
.................... void Get_Status(void) 
.................... { 
....................     int   Buffer[blksize];          // Buffer for data  
....................     Buffer[0] = STFlash_readStatus();  
*
1284:  RCALL  0E54
1286:  MOVFF  01,8D
....................     Buffer[1] = Buffer[0];  
128A:  MOVFF  8D,8E
....................     Buffer[2] = 'S';  
128E:  MOVLW  53
1290:  MOVWF  x8F
....................     usb_put_packet(1, Buffer, blksize ,USB_DTS_TOGGLE); 
1292:  MOVLW  01
1294:  MOVWF  xD6
1296:  CLRF   xD8
1298:  MOVLW  8D
129A:  MOVWF  xD7
129C:  CLRF   xDA
129E:  MOVLW  40
12A0:  MOVWF  xD9
12A2:  MOVLW  02
12A4:  MOVWF  xDB
12A6:  RCALL  0E8C
.................... } 
12A8:  GOTO   17F6 (RETURN)
....................  
.................... //-------------------------------------------------------------------------- 
.................... //    Get Status Register 
.................... //-------------------------------------------------------------------------- 
.................... void Get_ID(void) 
.................... { 
....................     int   Buffer[blksize];          // Buffer for data  
....................      
....................     Buffer[0] = 'J'; 
*
14D2:  MOVLW  4A
14D4:  MOVWF  x8D
....................     output_low(FLASH_SELECT);            // Enable select line 
14D6:  BCF    F8A.2
....................     STFlash_SendByte(0x9F);              // Send JDEC command 
14D8:  MOVLW  9F
14DA:  MOVWF  xEA
14DC:  RCALL  0DFC
....................     Buffer[1] = STFlash_GetByte();       // Get the ID; 
14DE:  RCALL  0E1E
14E0:  MOVFF  01,8E
....................     Buffer[2] = STFlash_GetByte();       // Get the ID;  
14E4:  RCALL  0E1E
14E6:  MOVFF  01,8F
....................     Buffer[3] = STFlash_GetByte();       // Get the ID;  
14EA:  RCALL  0E1E
14EC:  MOVFF  01,90
....................     output_high(FLASH_SELECT);           // Disable select line 
14F0:  BSF    F8A.2
....................     usb_put_packet(1, Buffer, blksize ,USB_DTS_TOGGLE); 
14F2:  MOVLW  01
14F4:  MOVWF  xD6
14F6:  CLRF   xD8
14F8:  MOVLW  8D
14FA:  MOVWF  xD7
14FC:  CLRF   xDA
14FE:  MOVLW  40
1500:  MOVWF  xD9
1502:  MOVLW  02
1504:  MOVWF  xDB
1506:  RCALL  0E8C
.................... } 
1508:  GOTO   17F6 (RETURN)
....................  
.................... //-------------------------------------------------------------------------- 
.................... //    Read 256 bytes from flash and return on comm line 
.................... //-------------------------------------------------------------------------- 
.................... void Read_Flash(int32 Address)  
.................... { 
....................     int   Buffer[blksize];          // Buffer for data  
....................     STFlash_ReadBlock(Address, Buffer, blksize); 
*
1386:  MOVFF  94,D8
138A:  MOVFF  93,D7
138E:  MOVFF  92,D6
1392:  MOVFF  91,D5
1396:  CLRF   xDA
1398:  MOVLW  95
139A:  MOVWF  xD9
139C:  CLRF   xDC
139E:  MOVLW  40
13A0:  MOVWF  xDB
13A2:  BRA    1348
....................     usb_put_packet(1, Buffer, blksize ,USB_DTS_TOGGLE); 
13A4:  MOVLW  01
13A6:  MOVWF  xD6
13A8:  CLRF   xD8
13AA:  MOVLW  95
13AC:  MOVWF  xD7
13AE:  CLRF   xDA
13B0:  MOVLW  40
13B2:  MOVWF  xD9
13B4:  MOVLW  02
13B6:  MOVWF  xDB
13B8:  RCALL  0E8C
.................... } 
13BA:  GOTO   17F6 (RETURN)
.................... //-------------------------------------------------------------------------- 
.................... //    Write 64 bytes to Flash 
.................... //-------------------------------------------------------------------------- 
.................... void Write_Flash(int32 Address)  
.................... { 
....................     int   Buffer[blksize];          // Buffer for data  
....................     while(!usb_kbhit(1)) usb_task(); 
*
1460:  BTFSC  1D.1
1462:  BRA    1468
1464:  RCALL  108E
1466:  BRA    1460
....................     usb_get_packet(1, Buffer, blksize); 
1468:  MOVLW  01
146A:  MOVWF  xD6
146C:  CLRF   xD8
146E:  MOVLW  95
1470:  MOVWF  xD7
1472:  CLRF   xDA
1474:  MOVLW  40
1476:  MOVWF  xD9
1478:  RCALL  1178
....................     STFlash_WriteBlock(Address, Buffer, blksize); 
147A:  MOVFF  94,D8
147E:  MOVFF  93,D7
1482:  MOVFF  92,D6
1486:  MOVFF  91,D5
148A:  CLRF   xDA
148C:  MOVLW  95
148E:  MOVWF  xD9
1490:  CLRF   xDC
1492:  MOVLW  40
1494:  MOVWF  xDB
1496:  BRA    13F2
....................     Buffer[0] = '1'; 
1498:  MOVLW  31
149A:  MOVWF  x95
....................     Buffer[1] = 'F'; 
149C:  MOVLW  46
149E:  MOVWF  x96
....................     usb_put_packet(1, Buffer, blksize ,USB_DTS_TOGGLE); 
14A0:  MOVLW  01
14A2:  MOVWF  xD6
14A4:  CLRF   xD8
14A6:  MOVLW  95
14A8:  MOVWF  xD7
14AA:  CLRF   xDA
14AC:  MOVLW  40
14AE:  MOVWF  xD9
14B0:  MOVLW  02
14B2:  MOVWF  xDB
14B4:  RCALL  0E8C
.................... } 
14B6:  GOTO   17F6 (RETURN)
....................  
.................... //---------------------------------------------------------------------------- 
.................... //---------------------------------------------------------------------------- 
.................... // FLASH TO FPGA Upload Functions: 
.................... //---------------------------------------------------------------------------- 
.................... //---------------------------------------------------------------------------- 
....................  
.................... //---------------------------------------------------------------------------- 
.................... // Upload FPGA Firmware from flash, Stored in FLASH as follows: 
.................... //------------------------------------------------------------------------------ 
.................... //     Start      End      Start       End      File    Actual 
.................... //   Address   Address   Address   Address     Space      Size Comment 
.................... // --------- --------- --------- --------- --------- --------- ----------------- 
.................... // 1,571,072 2,097,151 0x18_0000 0x1F_FFFF   524,288    Varies FPGA RBF 
.................... // 
.................... // example:  actual rbf file size = 218,713 bytes = 0x35659 
.................... // start = 0x180000 
.................... // end   = 0x180000 + 0x35659 = 1B_56_59   
.................... //---------------------------------------------------------------------------- 
.................... void FlashToFPGA(void) 
.................... { 
....................     int   Data; 
....................     int32 Address, End; 
....................      
....................     Address = get_ee_24(S_ADDR_RBF);    // Start Address 
*
0FAA:  MOVLW  0C
0FAC:  MOVWF  x96
0FAE:  RCALL  0D3C
0FB0:  MOVFF  03,91
0FB4:  MOVFF  02,90
0FB8:  MOVFF  01,8F
0FBC:  MOVFF  00,8E
....................     End     = get_ee_24(E_ADDR_RBF);    // End Address 
0FC0:  MOVLW  0F
0FC2:  MOVWF  x96
0FC4:  RCALL  0D3C
0FC6:  MOVFF  03,95
0FCA:  MOVFF  02,94
0FCE:  MOVFF  01,93
0FD2:  MOVFF  00,92
....................  
....................     Disable_FGPA_SPI();                 // Disable SPI slave mode 
0FD6:  RCALL  0D94
....................     Set_Tris_B(TRISB_Config);           // turn on output pin 
0FD8:  MOVLW  0F
0FDA:  MOVWF  F93
....................      
....................     delay_ms(5);                        // Short delay, settling     
0FDC:  MOVLW  05
0FDE:  MOVWF  xD6
0FE0:  RCALL  0DB4
....................     Init_Flash();                       // Now take over, PIC is master of flash 
0FE2:  RCALL  0F3E
....................  
....................     Output_Low(FPGALoad);               // FPGA Upload pin 
0FE4:  BCF    F8A.5
....................     delay_ms(50);                       // 50 ms delay to put FPGA into load mode 
0FE6:  MOVLW  32
0FE8:  MOVWF  xD6
0FEA:  RCALL  0DB4
....................     Output_High(FPGALoad);              // FPGA Upload pin 
0FEC:  BSF    F8A.5
....................     delay_ms(2);                        // Short delay, FPGA is disabled now 
0FEE:  MOVLW  02
0FF0:  MOVWF  xD6
0FF2:  RCALL  0DB4
....................  
....................     output_low(FLASH_SELECT);           // Enable select line 
0FF4:  BCF    F8A.2
....................     STFlash_sendByte(0x03);                 // Send opcode to read 
0FF6:  MOVLW  03
0FF8:  MOVWF  xEA
0FFA:  RCALL  0DFC
....................     STFlash_sendByte(Make8(Address, 2));    // Send address  
0FFC:  MOVFF  90,96
1000:  MOVFF  90,EA
1004:  RCALL  0DFC
....................     STFlash_sendByte(Make8(Address, 1));    // Send address 
1006:  MOVFF  8F,96
100A:  MOVFF  8F,EA
100E:  RCALL  0DFC
....................     STFlash_sendByte(Make8(Address, 0));    // Send address 
1010:  MOVFF  8E,96
1014:  MOVFF  8E,EA
1018:  RCALL  0DFC
....................     do { 
....................         Data = STFlash_GetByte(); 
101A:  RCALL  0E1E
101C:  MOVFF  01,8D
....................         LoadFPGAByte(Data);         
1020:  MOVFF  8D,D7
1024:  RCALL  0F68
....................         Address++; 
1026:  MOVLW  01
1028:  ADDWF  x8E,F
102A:  BTFSC  FD8.0
102C:  INCF   x8F,F
102E:  BTFSC  FD8.2
1030:  INCF   x90,F
1032:  BTFSC  FD8.2
1034:  INCF   x91,F
....................     } while(Address <= End); 
1036:  MOVF   x91,W
1038:  SUBWF  x95,W
103A:  BNC   1054
103C:  BNZ   101A
103E:  MOVF   x90,W
1040:  SUBWF  x94,W
1042:  BNC   1054
1044:  BNZ   101A
1046:  MOVF   x8F,W
1048:  SUBWF  x93,W
104A:  BNC   1054
104C:  BNZ   101A
104E:  MOVF   x8E,W
1050:  SUBWF  x92,W
1052:  BC    101A
....................     output_high(FLASH_SELECT);      // Disable select line, we are done reading 
1054:  BSF    F8A.2
....................     delay_ms(5);                    // Short delay, settling     
1056:  MOVLW  05
1058:  MOVWF  xD6
105A:  RCALL  0DB4
....................  
....................     Disable_STFlash();              // Disable Flash, yield to FPGA 
105C:  RCALL  0F84
....................     Set_Tris_B(TRISB_Disable);      // turn off output pin 
105E:  MOVLW  0F
1060:  MOVWF  F93
....................     delay_ms(5);                    // Short delay, settling     
1062:  MOVLW  05
1064:  MOVWF  xD6
1066:  RCALL  0DB4
....................     FGPA_SPI_Init();                // Enable SPI Interface    
1068:  RCALL  0F8E
.................... } 
106A:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Loads RBF from USB to FPGA  
.................... //------------------------------------------------------------------------------ 
.................... void USBToFPGA(int16 Blks, int Rmdr) 
.................... { 
....................     int16 i; 
....................     int8  Buffer[blksize], j, n; 
....................  
....................     Set_Tris_B(TRISB_Config);           // turn on output pin 
*
11B8:  MOVLW  0F
11BA:  MOVWF  F93
....................      
....................     Output_Low(FPGALoad);            // FPGA Upload pin 
11BC:  BCF    F8A.5
....................     delay_ms(50);                    // 50 ms delay to put FPGA into load mode 
11BE:  MOVLW  32
11C0:  MOVWF  xD6
11C2:  RCALL  0DB4
....................     Output_High(FPGALoad);           // FPGA Upload pin 
11C4:  BSF    F8A.5
....................     delay_ms(2);                     // Short delay 
11C6:  MOVLW  02
11C8:  MOVWF  xD6
11CA:  RCALL  0DB4
....................     for(i = 0; i < Blks; i++) { 
11CC:  CLRF   x93
11CE:  CLRF   x92
11D0:  MOVF   x93,W
11D2:  SUBWF  x90,W
11D4:  BNC   1246
11D6:  BNZ   11DE
11D8:  MOVF   x8F,W
11DA:  SUBWF  x92,W
11DC:  BC    1246
....................         usb_get_packet(1, Buffer, blksize); 
11DE:  MOVLW  01
11E0:  MOVWF  xD6
11E2:  CLRF   xD8
11E4:  MOVLW  94
11E6:  MOVWF  xD7
11E8:  CLRF   xDA
11EA:  MOVLW  40
11EC:  MOVWF  xD9
11EE:  RCALL  1178
....................         if(i == Blks-1) n = Rmdr;       // Last block 
11F0:  MOVLW  01
11F2:  SUBWF  x8F,W
11F4:  MOVWF  00
11F6:  MOVLW  00
11F8:  SUBWFB x90,W
11FA:  MOVWF  03
11FC:  MOVF   00,W
11FE:  SUBWF  x92,W
1200:  BNZ   120E
1202:  MOVF   03,W
1204:  SUBWF  x93,W
1206:  BNZ   120E
1208:  MOVFF  91,D5
....................         else            n = blksize;    // regular block 
120C:  BRA    1212
120E:  MOVLW  40
1210:  MOVWF  xD5
....................         for(j = 0; j < n; j++) LoadFPGAByte(Buffer[j]); 
1212:  CLRF   xD4
1214:  MOVF   xD5,W
1216:  SUBWF  xD4,W
1218:  BC    1236
121A:  CLRF   03
121C:  MOVF   xD4,W
121E:  ADDLW  94
1220:  MOVWF  FE9
1222:  MOVLW  00
1224:  ADDWFC 03,W
1226:  MOVWF  FEA
1228:  MOVFF  FEF,D6
122C:  MOVFF  D6,D7
1230:  RCALL  0F68
1232:  INCF   xD4,F
1234:  BRA    1214
....................         while(!usb_kbhit(1)) usb_task(); 
1236:  BTFSC  1D.1
1238:  BRA    123E
123A:  RCALL  108E
123C:  BRA    1236
....................     }     
123E:  INCF   x92,F
1240:  BTFSC  FD8.2
1242:  INCF   x93,F
1244:  BRA    11D0
....................      
....................     Set_Tris_B(TRISB_Disable);      // turn off output pin 
1246:  MOVLW  0F
1248:  MOVWF  F93
.................... } 
124A:  GOTO   17F6 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // R T C   Control Routines 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Refresh data from RTC into SPI buffer 
.................... //------------------------------------------------------------------------------ 
.................... void Refresh_RTCSPI(void) 
.................... { 
....................     int i;  
....................     for(i=0; i < 8; i++) spi_buffer[i] = RTCRead(i);  // Update the spi window 
*
0CE0:  CLRF   50
0CE2:  MOVF   50,W
0CE4:  SUBLW  07
0CE6:  BNC   0D12
0CE8:  CLRF   03
0CEA:  MOVF   50,W
0CEC:  ADDLW  2B
0CEE:  MOVWF  01
0CF0:  MOVLW  00
0CF2:  ADDWFC 03,F
0CF4:  MOVFF  01,51
0CF8:  MOVFF  03,52
0CFC:  MOVFF  50,D0
0D00:  RCALL  0CB4
0D02:  MOVFF  52,FEA
0D06:  MOVFF  51,FE9
0D0A:  MOVFF  01,FEF
0D0E:  INCF   50,F
0D10:  BRA    0CE2
.................... } 
0D12:  RETLW  00
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Reads all data from RTC and send back on USB 
.................... //------------------------------------------------------------------------------ 
.................... void Read_RTC(void) 
.................... { 
....................     int i, Buffer[blksize];          // Buffer for data  
....................      
....................     for(i=0; i <32; i++) Buffer[i] = RTCRead(i); 
*
150C:  CLRF   x8D
150E:  MOVF   x8D,W
1510:  SUBLW  1F
1512:  BNC   1540
1514:  CLRF   03
1516:  MOVF   x8D,W
1518:  ADDLW  8E
151A:  MOVWF  01
151C:  MOVLW  00
151E:  ADDWFC 03,F
1520:  MOVFF  01,CE
1524:  MOVFF  03,CF
1528:  MOVFF  8D,D0
152C:  CALL   0CB4
1530:  MOVFF  CF,FEA
1534:  MOVFF  CE,FE9
1538:  MOVFF  01,FEF
153C:  INCF   x8D,F
153E:  BRA    150E
....................     Buffer[32] = 'R'; 
1540:  MOVLW  52
1542:  MOVWF  xAE
....................     usb_put_packet(1, Buffer, blksize ,USB_DTS_TOGGLE); 
1544:  MOVLW  01
1546:  MOVWF  xD6
1548:  CLRF   xD8
154A:  MOVLW  8E
154C:  MOVWF  xD7
154E:  CLRF   xDA
1550:  MOVLW  40
1552:  MOVWF  xD9
1554:  MOVLW  02
1556:  MOVWF  xDB
1558:  RCALL  0E8C
.................... }     
155A:  GOTO   17F6 (RETURN)
....................      
.................... //------------------------------------------------------------------------------ 
.................... // Write all data to RTC  
.................... //------------------------------------------------------------------------------ 
.................... void Write_RTC(int data[]) 
.................... { 
....................     int i;  
....................     for(i=0; i <32; i++) RTCWrite(i, data[i+1]); 
*
1588:  CLRF   x8F
158A:  MOVF   x8F,W
158C:  SUBLW  1F
158E:  BNC   15B2
1590:  MOVLW  01
1592:  ADDWF  x8F,W
1594:  CLRF   03
1596:  ADDWF  x8D,W
1598:  MOVWF  FE9
159A:  MOVF   x8E,W
159C:  ADDWFC 03,W
159E:  MOVWF  FEA
15A0:  MOVFF  FEF,91
15A4:  MOVFF  8F,92
15A8:  MOVFF  91,93
15AC:  RCALL  155E
15AE:  INCF   x8F,F
15B0:  BRA    158A
.................... } 
15B2:  GOTO   17F6 (RETURN)
....................      
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... // ZBC FPGA to PIC SPI Interface Section: 
.................... // ZBC is the master, PIC is the slave in this case. PIC (this program) waits 
.................... // in main loop for a command. When received takes action and then returns the  
.................... // results. The command structure is a 3 bit command followed by a 5 bit address. 
.................... // The commands are as follows, first 3 bit are the command, last 5 are the address. 
.................... // 
.................... //     Command  Description 
.................... //    --------  ------------------------ 
.................... // 0  000xxxxx  No Operation 
.................... // 1  001xxxxx  Read from SPI buffer window at specified address 
.................... // 2  010xxxxx  Write to SPI buffer window  at specified address 
.................... // 3  011xxxxx  Refresh contents of SPI buffer window 
.................... // 4  100xxxxx  Reserved for future use 
.................... // 5  101xxxxx  Reserved for future use 
.................... // 6  110xxxxx  Reserved for future use 
.................... // 7  111xxxxx  No Operation 
.................... // 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Handle SPI Request from ZBC: 
.................... //------------------------------------------------------------------------------ 
.................... void Handle_SPI(void) 
.................... { 
....................     int data, cmd, addr; 
....................  
....................     data = ssp_get();       // Get current request from ZBC and return last 
*
17FA:  MOVFF  FC9,4D
....................     cmd  = data>>5; 
17FE:  SWAPF  4D,W
1800:  MOVWF  4E
1802:  RRCF   4E,F
1804:  MOVLW  07
1806:  ANDWF  4E,F
....................     addr = data & 0x1F; 
1808:  MOVF   4D,W
180A:  ANDLW  1F
180C:  MOVWF  4F
....................     
....................     if(cmd == 1) {         // User requested a read 
180E:  DECFSZ 4E,W
1810:  BRA    1828
....................         ssp_put(spi_buffer[addr]); 
1812:  CLRF   03
1814:  MOVF   4F,W
1816:  ADDLW  2B
1818:  MOVWF  FE9
181A:  MOVLW  00
181C:  ADDWFC 03,W
181E:  MOVWF  FEA
1820:  MOVFF  FEF,FC9
....................         spi_write = false; 
1824:  BCF    2A.1
....................     } 
....................     else { 
1826:  BRA    182C
....................         ssp_put(0xFF);  
1828:  MOVLW  FF
182A:  MOVWF  FC9
....................     } 
....................      
....................     if(cmd == 2) {         // User requested a write 
182C:  MOVF   4E,W
182E:  SUBLW  02
1830:  BNZ   1834
....................         spi_write = true; 
1832:  BSF    2A.1
....................     } 
....................      
....................     if(cmd == 3) Refresh_RTCSPI();  // Refresh data from RTC into SPI buffer 
1834:  MOVF   4E,W
1836:  SUBLW  03
1838:  BNZ   183E
183A:  CALL   0CE0
....................  
.................... } 
183E:  GOTO   18E8 (RETURN)
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Exchange data between SPI and USB 
.................... //------------------------------------------------------------------------------ 
.................... void FPGA_SPI_Xfer(int data[]) 
.................... { 
....................     int i, Buffer[blksize];          // Buffer for data  
....................  
....................     for(i=0; i <32; i++) Buffer[i]     = spi_buffer[i]; // from spi buffer to usb 
*
15B6:  CLRF   x8F
15B8:  MOVF   x8F,W
15BA:  SUBLW  1F
15BC:  BNC   15F0
15BE:  CLRF   03
15C0:  MOVF   x8F,W
15C2:  ADDLW  90
15C4:  MOVWF  01
15C6:  MOVLW  00
15C8:  ADDWFC 03,F
15CA:  MOVFF  03,D1
15CE:  CLRF   03
15D0:  MOVF   x8F,W
15D2:  ADDLW  2B
15D4:  MOVWF  FE9
15D6:  MOVLW  00
15D8:  ADDWFC 03,W
15DA:  MOVWF  FEA
15DC:  MOVFF  FEF,D2
15E0:  MOVFF  D1,FEA
15E4:  MOVFF  01,FE9
15E8:  MOVFF  D2,FEF
15EC:  INCF   x8F,F
15EE:  BRA    15B8
....................     for(i=0; i <32; i++) spi_buffer[i] = data[i];       // From USB to spi buffer 
15F0:  CLRF   x8F
15F2:  MOVF   x8F,W
15F4:  SUBLW  1F
15F6:  BNC   162A
15F8:  CLRF   03
15FA:  MOVF   x8F,W
15FC:  ADDLW  2B
15FE:  MOVWF  01
1600:  MOVLW  00
1602:  ADDWFC 03,F
1604:  MOVFF  03,D1
1608:  CLRF   03
160A:  MOVF   x8F,W
160C:  ADDWF  x8D,W
160E:  MOVWF  FE9
1610:  MOVF   x8E,W
1612:  ADDWFC 03,W
1614:  MOVWF  FEA
1616:  MOVFF  FEF,D2
161A:  MOVFF  D1,FEA
161E:  MOVFF  01,FE9
1622:  MOVFF  D2,FEF
1626:  INCF   x8F,F
1628:  BRA    15F2
....................     Buffer[34] = 'C'; 
162A:  MOVLW  43
162C:  MOVWF  xB2
....................     usb_put_packet(1, Buffer, blksize ,USB_DTS_TOGGLE); 
162E:  MOVLW  01
1630:  MOVWF  xD6
1632:  CLRF   xD8
1634:  MOVLW  90
1636:  MOVWF  xD7
1638:  CLRF   xDA
163A:  MOVLW  40
163C:  MOVWF  xD9
163E:  MOVLW  02
1640:  MOVWF  xDB
1642:  RCALL  0E8C
.................... }     
1644:  GOTO   17F6 (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... //  U S B  C o n t r o l   F u n c t i o n s 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // When called, displays debugging information over serial to display enumeration  
.................... // and connection states.  Also lights LED2 and LED3 based upon enumeration and connection status. 
.................... //------------------------------------------------------------------------------ 
.................... void usb_debug_task(void)  
.................... { 
....................     static int8 last_connected; 
....................     static int8 last_enumerated; 
....................     int8 new_connected; 
....................     int8 new_enumerated; 
....................  
....................     new_connected   = usb_attached(); 
....................     new_enumerated  = usb_enumerated(); 
....................     last_connected  = new_connected; 
....................     last_enumerated = new_enumerated; 
.................... } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Receives a packet of data.  The protocol was specified in the HID 
.................... // report descriptor (see usb_desc_robomouse.h), PC->PIC and is: 
.................... //     msg[0] = 0x00   // Report ID 
.................... //     msg[1] = var1   // First byte of data 
.................... //     msg[2] = var2   // Secnod byte of data 
.................... //      . 
.................... //      . 
.................... //  Valid  
.................... //  Commands  Description 
.................... //  --------  ------------------------------------------------------------------ 
.................... //      0x09  Turn test LED on or off, if var1 = 1, turn on, var1 = 0, turn off 
.................... //      0x0B  Set or reset floppy boot option 
.................... //      0x0F  Set or clear FPGA load pin and or FPGA Reset Pin 
.................... //      0x10  Upload RBF file from USB line, var1, 2 & 3 are the number of bytes 
.................... //      0x11  Command to configure FPGA from a file stored in FLASH 
.................... //      0x20  Write 1 byte to EEPROM, var1 is address and var2 is the data 
.................... //      0x21  Read 1 byte from EEPROM, var1 is address, data returned in USB report 
.................... //      0x90  Initialize Flash RAM (Makes PIC the SPI master) 
.................... //      0x91  Returns status of Flash RAM in a USB report 
.................... //      0x92  Erase a 64K block from Flash, var1, 2 & 3 make the address   
.................... //      0x93  Read a 64 byte block from Flash, var1,2&3 address, data returned USB 
.................... //      0x94  Write 64 bytes from USB, var1,2&3 address, data in next report 
.................... //      0x95  Write to Flash Status register, var1 is value to write 
.................... //      0x96  Get the Flash Chip ID return in USB report 
.................... //      0x9F  Diables the Flash, makes PIC an SPI Slave 
.................... //      0xA1  Read 32 bytes from RTC, var1 is address, return 32 bytes data in USB report  
.................... //      0xA2  Write 32 byte to RTC, var1 is address, var2 on is data 
.................... //      0xA3  Write 1 byte to RTC, var1 is address, var2 is data 
.................... //      0xB1  FPGA data transfer,  
.................... //      0xB2  FPGA SPI enabled if var=1, elase disabled  
.................... // 
.................... //------------------------------------------------------------------------------ 
.................... void usb_rcvdata_task(void)  
.................... { 
....................     int data[blksize]; 
....................     if(usb_kbhit(1)) { 
1648:  BTFSS  1D.1
164A:  BRA    17F6
....................         usb_get_packet(1, data, 40);   
164C:  MOVLW  01
164E:  MOVWF  xD6
1650:  CLRF   xD8
1652:  MOVLW  4D
1654:  MOVWF  xD7
1656:  CLRF   xDA
1658:  MOVLW  28
165A:  MOVWF  xD9
165C:  RCALL  1178
....................         switch(data[0]) { 
165E:  MOVF   4D,W
1660:  XORLW  09
1662:  BZ    16CE
1664:  XORLW  02
1666:  BZ    16DA
1668:  XORLW  04
166A:  BZ    16E6
166C:  XORLW  1F
166E:  BZ    16FC
1670:  XORLW  01
1672:  BZ    1712
1674:  XORLW  31
1676:  BZ    1716
1678:  XORLW  01
167A:  BTFSC  FD8.2
167C:  BRA    1744
167E:  XORLW  B1
1680:  BTFSC  FD8.2
1682:  BRA    174A
1684:  XORLW  01
1686:  BTFSC  FD8.2
1688:  BRA    1750
168A:  XORLW  03
168C:  BTFSC  FD8.2
168E:  BRA    1752
1690:  XORLW  01
1692:  BTFSC  FD8.2
1694:  BRA    1774
1696:  XORLW  07
1698:  BTFSC  FD8.2
169A:  BRA    1796
169C:  XORLW  01
169E:  BTFSC  FD8.2
16A0:  BRA    17B8
16A2:  XORLW  03
16A4:  BTFSC  FD8.2
16A6:  BRA    17BE
16A8:  XORLW  09
16AA:  BTFSC  FD8.2
16AC:  BRA    17C0
16AE:  XORLW  3E
16B0:  BTFSC  FD8.2
16B2:  BRA    17C6
16B4:  XORLW  03
16B6:  BTFSC  FD8.2
16B8:  BRA    17C8
16BA:  XORLW  01
16BC:  BTFSC  FD8.2
16BE:  BRA    17D0
16C0:  XORLW  12
16C2:  BTFSC  FD8.2
16C4:  BRA    17DC
16C6:  XORLW  03
16C8:  BTFSC  FD8.2
16CA:  BRA    17E4
16CC:  BRA    17F4
....................  
....................             //------------------------------------------------------------------ 
....................             // Basic Functions 
....................             //------------------------------------------------------------------ 
....................             case 0x09: if(Bit_Test(data[1],0)) LED_OFF(TestLED); 
16CE:  BTFSS  4E.0
16D0:  BRA    16D6
16D2:  BCF    F89.4
....................                        else                    LED_ON(TestLED); 
16D4:  BRA    16D8
16D6:  BSF    F89.4
....................                        break; 
16D8:  BRA    17F6
....................                         
....................             case 0x0B: if(Bit_Test(data[1],0)) Output_Low (FLOPPY_SEL); 
16DA:  BTFSS  4E.0
16DC:  BRA    16E2
16DE:  BCF    F8A.7
....................                        else                    Output_High(FLOPPY_SEL); 
16E0:  BRA    16E4
16E2:  BSF    F8A.7
....................                        break; 
16E4:  BRA    17F6
....................  
....................             case 0x0F: if(Bit_Test(data[1],0)) Output_Low(FPGALoad);  // FPGA Upload pin 
16E6:  BTFSS  4E.0
16E8:  BRA    16EE
16EA:  BCF    F8A.5
....................                        else                    Output_High(FPGALoad); // FPGA Upload pin 
16EC:  BRA    16F0
16EE:  BSF    F8A.5
....................                        if(Bit_Test(data[1],1)) Output_Low(FPGAReset);  // FPGA Reset pin 
16F0:  BTFSS  4E.1
16F2:  BRA    16F8
16F4:  BCF    F8A.4
....................                        else                    Output_High(FPGAReset); // FPGA Reset pin                        
16F6:  BRA    16FA
16F8:  BSF    F8A.4
....................                        break; 
16FA:  BRA    17F6
....................  
....................             case 0x10: USBToFPGA(make16(data[1],data[2]),data[3]);  // Loads USB to FPGA 
16FC:  MOVFF  4E,8E
1700:  MOVFF  4F,8D
1704:  MOVFF  4E,90
1708:  MOVFF  4F,8F
170C:  MOVFF  50,91
1710:  BRA    11B8
....................                        break; 
....................  
....................             case 0x11: FlashToFPGA();  // Loads RBF from Flash to FPGA 
1712:  RCALL  0FAA
....................                        break; 
1714:  BRA    17F6
....................  
....................             //------------------------------------------------------------------ 
....................             // EE PROM Functions 
....................             //------------------------------------------------------------------ 
....................             case 0x20: write_eeprom(data[1], data[2]); // Write a value to EEPROM 
1716:  MOVFF  4E,FA9
171A:  MOVFF  4F,FA8
171E:  BCF    FA6.6
1720:  BCF    FA6.7
1722:  BSF    FA6.2
1724:  MOVFF  FF2,00
1728:  BCF    FF2.7
172A:  MOVLB  F
172C:  MOVLW  55
172E:  MOVWF  FA7
1730:  MOVLW  AA
1732:  MOVWF  FA7
1734:  BSF    FA6.1
1736:  BTFSC  FA6.1
1738:  BRA    1736
173A:  BCF    FA6.2
173C:  MOVF   00,W
173E:  IORWF  FF2,F
....................                        break;  
1740:  MOVLB  0
1742:  BRA    17F6
....................  
....................             case 0x21: Get_EEPROM(data[1]); // Read a value from EEPROM 
1744:  MOVFF  4E,8D
1748:  BRA    124E
....................                        break; 
....................  
....................             //------------------------------------------------------------------ 
....................             // ST FLASh RAM Functions 
....................             //------------------------------------------------------------------ 
....................             case 0x90: Init_Flash(); 
174A:  CALL   0F3E
....................                        break;  
174E:  BRA    17F6
....................  
....................             case 0x91: Get_Status(); 
1750:  BRA    1284
....................                        break;  
....................  
....................             case 0x92: STFlash_EraseBlock(Make32(data[1],data[2],data[3],data[4])); 
1752:  MOVFF  4E,90
1756:  MOVFF  4F,8F
175A:  MOVFF  50,8E
175E:  MOVFF  51,8D
1762:  MOVFF  4E,94
1766:  MOVFF  4F,93
176A:  MOVFF  50,92
176E:  MOVFF  51,91
1772:  BRA    12C4
....................                        break;  
....................                         
....................             case 0x93: Read_Flash(Make32(data[1],data[2],data[3],data[4])); 
1774:  MOVFF  4E,90
1778:  MOVFF  4F,8F
177C:  MOVFF  50,8E
1780:  MOVFF  51,8D
1784:  MOVFF  4E,94
1788:  MOVFF  4F,93
178C:  MOVFF  50,92
1790:  MOVFF  51,91
1794:  BRA    1386
....................                        break;  
....................  
....................             case 0x94: Write_Flash(Make32(data[1],data[2],data[3],data[4])); 
1796:  MOVFF  4E,90
179A:  MOVFF  4F,8F
179E:  MOVFF  50,8E
17A2:  MOVFF  51,8D
17A6:  MOVFF  4E,94
17AA:  MOVFF  4F,93
17AE:  MOVFF  50,92
17B2:  MOVFF  51,91
17B6:  BRA    1460
....................                        break;  
....................  
....................             case 0x95: STFlash_writeStatus(data[1]); 
17B8:  MOVFF  4E,8D
17BC:  BRA    14BA
....................                        break;  
....................  
....................             case 0x96: Get_ID(); 
17BE:  BRA    14D2
....................                        break;  
....................                         
....................             case 0x9F: Disable_STFlash();           // Disable Flash, yield to FPGA 
17C0:  CALL   0F84
....................                        break; 
17C4:  BRA    17F6
....................  
....................  
....................             //------------------------------------------------------------------ 
....................             // RTC Functions 
....................             //------------------------------------------------------------------ 
....................             case 0xA1: Read_RTC();                 // Read all data from RTC 
17C6:  BRA    150C
....................                        break;  
....................  
....................             case 0xA2: Write_RTC(data);            // Write all data to RTC 
17C8:  CLRF   x8E
17CA:  MOVLW  4D
17CC:  MOVWF  x8D
17CE:  BRA    1588
....................                        break;  
....................  
....................             case 0xA3: RTCWrite(data[1], data[2]); // Write 1 Byte of data to RTC 
17D0:  MOVFF  4E,92
17D4:  MOVFF  4F,93
17D8:  RCALL  155E
....................                        break;  
17DA:  BRA    17F6
....................  
....................             //------------------------------------------------------------------ 
....................             // FPGA SPI Functions 
....................             //------------------------------------------------------------------ 
....................             case 0xB1: FPGA_SPI_Xfer(data);     // Transfer data over SPI 
17DC:  CLRF   x8E
17DE:  MOVLW  4D
17E0:  MOVWF  x8D
17E2:  BRA    15B6
....................                        break;  
....................  
....................             case 0xB2: if(data[1]==0x01) FGPA_SPI_Init();    
17E4:  DECFSZ 4E,W
17E6:  BRA    17EE
17E8:  CALL   0F8E
....................                        else              Disable_FGPA_SPI(); 
17EC:  BRA    17F2
17EE:  CALL   0D94
....................                        break;  
17F2:  BRA    17F6
....................  
....................  
....................             default:   break; 
17F4:  BRA    17F6
....................         } 
....................     } 
.................... } 
17F6:  GOTO   18DE (RETURN)
....................  
.................... //------------------------------------------------------------------------------ 
.................... //  End .h 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... //    Main Function:                                                           
.................... //------------------------------------------------------------------------------ 
.................... void main() 
.................... { 
*
1842:  CLRF   FF8
1844:  BCF    FD0.7
1846:  BSF    0D.7
1848:  CLRF   FEA
184A:  CLRF   FE9
184C:  MOVF   FC1,W
184E:  ANDLW  C0
1850:  IORLW  0F
1852:  MOVWF  FC1
1854:  MOVLW  07
1856:  MOVWF  FB4
1858:  CLRF   1F
185A:  CLRF   21
185C:  MOVLW  04
185E:  MOVWF  22
1860:  MOVLW  0C
1862:  MOVWF  23
1864:  CLRF   26
1866:  CLRF   28
1868:  CLRF   29
186A:  CLRF   4B
186C:  CLRF   4C
....................     //-------------------------------------------------------------------------- 
....................     //  PIC Initialization Section 
....................     //-------------------------------------------------------------------------- 
....................     Disable_Interrupts(GLOBAL);                 // all interrupts OFF 
186E:  BCF    FF2.6
1870:  BCF    FF2.7
1872:  BTFSC  FF2.7
1874:  BRA    1870
....................     Setup_adc(ADC_OFF);                         // ADC not needed 
1876:  BCF    FC2.0
....................     Setup_adc_ports(NO_ANALOGS);                // No ADC ports needed  
1878:  MOVF   FC1,W
187A:  ANDLW  C0
187C:  IORLW  0F
187E:  MOVWF  FC1
....................     Setup_timer_0(RTCC_INTERNAL|RTCC_DIV_256);  // Timer 0 set for  42.6us,  
1880:  MOVLW  87
1882:  MOVWF  FD5
....................     Setup_timer_1(T1_DISABLED);                 // Timer 1   
1884:  CLRF   FCD
....................  
....................     Set_Tris_A(TRISA_Enabled);          // SPI Disabled 
1886:  MOVLW  2F
1888:  MOVWF  F92
....................     Set_Tris_B(TRISB_Disable);          // Flash SPI Disabled  
188A:  MOVLW  0F
188C:  MOVWF  F93
....................     Set_Tris_C(TRISC_Disable);          // Flash SPI Disabled 
188E:  MOVLW  88
1890:  MOVWF  F94
....................  
....................     Output_high(FLASH_SELECT);          // Slash Select High 
1892:  BSF    F8A.2
....................     Output_low(FLASH_CLOCK);           // Pulse the clock 
1894:  BCF    F8A.1
....................     Output_low(RTC_RST);                // Disable RTC 
1896:  BCF    F8B.2
....................     Output_High(FPGALoad);              // FPGA Upload pin 
1898:  BSF    F8A.5
....................     Output_High(FPGAReset);             // FPGA reset off 
189A:  BSF    F8A.4
....................     Output_High(TestLED);               // indication of boot up 
189C:  BSF    F89.4
....................  
....................     spi_enabled   = False;              // ZBC to PIC SPI disabled initially 
189E:  BCF    2A.0
....................     spi_write     = False;              // ZBC to PIC SPI disabled initially 
18A0:  BCF    2A.1
....................      
....................     Refresh_RTCSPI();                   // Refresh data from RTC into SPI buffer 
18A2:  CALL   0CE0
....................  
....................     //-------------------------------------------------------------------------- 
....................     //  USB Initialization Section             
....................     //-------------------------------------------------------------------------- 
....................     usb_init_cs();                      // Initialize the USB Connection 
18A6:  GOTO   0D14
....................     if(read_eeprom(BOOT_TYPE) > 0) {    // We want boot from FLASH 
18AA:  MOVFF  FF2,4D
18AE:  BCF    FF2.7
18B0:  MOVLW  12
18B2:  MOVWF  FA9
18B4:  BCF    FA6.6
18B6:  BCF    FA6.7
18B8:  BSF    FA6.0
18BA:  MOVF   FA8,W
18BC:  BTFSC  4D.7
18BE:  BSF    FF2.7
18C0:  XORLW  00
18C2:  BZ    18D0
....................         FlashToFPGA();                  // If not hooked up to USB then try to init 
18C4:  CALL   0FAA
....................         Output_Low(FPGAReset);          // FPGA reset off 
18C8:  BCF    F8A.4
....................         Output_High(FPGAReset);         // FPGA reset off 
18CA:  BSF    F8A.4
....................         Output_Low(TestLED);            // Turn off Test LED 
18CC:  BCF    F89.4
....................     } 
....................     else { 
18CE:  BRA    18D4
....................         FGPA_SPI_Init();                // Put PIC in SPI Slave mode  
18D0:  CALL   0F8E
....................     } 
....................      
....................     //-------------------------------------------------------------------------- 
....................     //  Main Command Loop:             
....................     //-------------------------------------------------------------------------- 
....................     do {                                // Always do USB Task 
....................         usb_task();                     // so it will detect USB pluging in  
18D4:  CALL   108E
....................         if(usb_enumerated()) {          // Are we plugged into the USB port ? 
18D8:  MOVF   1A,F
18DA:  BZ    18DE
....................             usb_rcvdata_task();         // If so, check for data  
18DC:  BRA    1648
....................         } 
....................         if(spi_enabled) {               // if ZBC to PIC SPI enabled, then check  
18DE:  BTFSS  2A.0
18E0:  BRA    18E8
....................             if(SSP_HAS_DATA()) { 
18E2:  BTFSS  FC7.0
18E4:  BRA    18E8
....................                 Handle_SPI();           // Handle SPI request from ZBC 
18E6:  BRA    17FA
....................             } 
....................         }                               // Otherwise... just 
....................     } while(True);                      // Continue forever, what else can we do ? 
.................... } 
18E8:  BRA    18D4
.................... //------------------------------------------------------------------------------ 
.................... //  End .c 
.................... //------------------------------------------------------------------------------ 
....................  
18EA:  SLEEP 

Configuration Fuses:
   Word  1: 0E2C   NOIESO NOFCMEN HSPLL PLL5 CPUDIV2 USBDIV
   Word  2: 1E38   NOBROWNOUT NOWDT BORV20 PUT WDT32768 VREGEN
   Word  3: 8100   NOPBADEN CCP2C1 MCLR NOLPT1OSC RESERVED
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST RESERVED
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
